<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>0x02 Advanced Windows Internals | Tx0actical's Blog</title><meta name=keywords content="Drivers,Windows"><meta name=description content="Writing Windows KMDF Drivers for Fun and Exploitation - Part 2"><meta name=author content="Tx0actical"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b76ef1d1105cc5a21dd3ec17e516b581bec6eddf19af9e1bec802fc185a8b1d7.css integrity="sha256-t27x0RBcxaId0+wX5Ra1gb7G7d8Zr54b7IAvwYWosdc=" rel="preload stylesheet" as=style><link rel=icon href=https://Tx0actical.github.io/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Tx0actical.github.io/favicon_io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Tx0actical.github.io/favicon_io/favicon-32x32.png><link rel=apple-touch-icon href=https://Tx0actical.github.io/favicon_io/apple-touch-icon.png><link rel=mask-icon href=https://Tx0actical.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-S0DZQ0T5JT"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-S0DZQ0T5JT",{anonymize_ip:!1})}</script><meta property="og:title" content="0x02 Advanced Windows Internals"><meta property="og:description" content="Writing Windows KMDF Drivers for Fun and Exploitation - Part 2"><meta property="og:type" content="article"><meta property="og:url" content="https://Tx0actical.github.io/posts/win-drivers/win-drivers-p2/"><meta property="og:image" content="https://Tx0actical.github.io/images/Lissajous_curve_5by4.svg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-24T12:53:24+05:30"><meta property="article:modified_time" content="2023-03-24T12:53:24+05:30"><meta property="og:site_name" content="Tx0actical's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://Tx0actical.github.io/images/Lissajous_curve_5by4.svg"><meta name=twitter:title content="0x02 Advanced Windows Internals"><meta name=twitter:description content="Writing Windows KMDF Drivers for Fun and Exploitation - Part 2"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://Tx0actical.github.io/posts/"},{"@type":"ListItem","position":2,"name":"0x02 Advanced Windows Internals","item":"https://Tx0actical.github.io/posts/win-drivers/win-drivers-p2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"0x02 Advanced Windows Internals","name":"0x02 Advanced Windows Internals","description":"Writing Windows KMDF Drivers for Fun and Exploitation - Part 2","keywords":["Drivers","Windows"],"articleBody":"Hello.\nKMDF (or WDF for that matter) being a Windows thing, you need to understand some Windows fundamentals.\nIn this iteration, Part 2, of “Writing Windows KMDF Drivers for Fun and Profit”, I’ll introduce you to important Windows Concepts such as Processes, Threads, Virtual Memory, System Services, Objects and Handles, Subsystems, and the Hyper-V Hypervisor. You’ll discover these constructs in great detail in this post. This post is informational and explorational in nature and can be treated as a reference, if you will.\nWith this, I wanted to focus on experimentation and a deep-dive explanation and do something different instead of replaying information that already exists. Output of various debugger commands are snipped indicated by a ... for the sake of brevity.\nAnyone who’s ever dug a little deep about Windows might be familiar with this image:\nGeneral Architecture, Source: Windows Internals, Part 1.\nWe’ll now examine this architecture in detail.\nProcesses A process is a management and containment object which represents an instance of a program. Contrary to popular belief, processes don’t run, they “manage”. Each Windows process is defined by an executive process structure or nt!_EPROCESS. This structure (typedef struct _EPROCESS EPROCESS, *PEPROCESS to be exact) is the kernel’s representation of a process object. It exists only in kernel memory, user-mode can access indirectly through handles (handles are explained later). The Windows kernel maintains a nt!_EPROCESS structure for every process including -\u003e System Idle Process (PID 0) and System (Process) (PID 4).\nIt is an opaque kernel structure defined as -\u003e\n1 2 3 typedef struct _EPROCESS { ... // Opaque } EPROCESS, *PEPROCESS; nt!_EPROCESS and its constituent data structures are contained in the System address space and can be examined from kernel mode, except for Process Control Block (PCB) which exists in User space.\nMoreover, the subsystem service csrss.exe maintains a parallel data structure CSR_PROCESS. Additionally, the kernel mode part of the subsystem Win32k.sys maintains a per-process data structure, W32PROCESS. Except for the idle process, every process has a process object associated with it.\nThis post introduces you to the Kernel Debugger. It is a useful tool to examine internal components. To get started, you’ll need to -\u003e\nEnable debugging. To do that, in an elevated command prompt, type bcdedit /debug on and restart. If secure boot is enabled, might need to do additional changes in the boot menu (You can avoid the hassle of tinkering with BIOS options. Instead, use a VM. Follow the above-mentioned steps, and you’ll be good to go). Install “WinDbg Preview” from Microsoft Store. After it’s installed, go to ‘Home’ -\u003e ‘Attach to kernel’ -\u003e Select ‘Local’. This will start a Local Kernel Debugging Session. Once there, you can type all the commands in lkd in the command window. To see all processes, use !process 0 0 in the Kernel Debugger. But the output would be huge. Instead, we’ll use !process with no arguments which will list information for the process owning the thread that is currently executing on CPU 0, or the current Debugging process.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 lkd\u003e !process PROCESS ffff9f016a6e4080 SessionId: 1 Cid: 067c Peb: 293d469000 ParentCid: 09bc DirBase: 5bb72002 ObjectTable: ffffcd04ce0bdd00 HandleCount: 700. Image: DbgX.Shell.exe VadRoot ffff9f016a9c0450 Vads 697 Clone 0 Private 36707. Modified 1193. Locked 10123. DeviceMap ffffcd04cb15b170 Token ffffcd04ce048770 ElapsedTime 00:14:32.628 UserTime 00:00:11.062 KernelTime 00:00:02.484 QuotaPoolUsage[PagedPool] 689520 QuotaPoolUsage[NonPagedPool] 95456 Working Set Sizes (now,min,max) (58644, 50, 345) (234576KB, 200KB, 1380KB) PeakWorkingSetSize 68423 VirtualSize 2102310 Mb PeakVirtualSize 2102367 Mb PageFaultCount 206265 MemoryPriority FOREGROUND BasePriority 8 CommitCharge 40393 Job ffff9f016a4a3060 This returns the address of Process Environment Block (PEB) which is the user-mode representation of the process. It contains the information by image loader, heap manager, and other Windows components that need access to it from user mode. This corresponds to the image -\u003e DbgX.Shell.exe (which is the current debug shell process). To examine its peb we need to switch the current context to that process, this can be done using .process /p with the process address, 0xffff9f016a6e4080 in this case. Then examine the peb using !peb with the address passed as a parameter, which is 0x293d469000. The complete command is -\u003e .process /p ffff9f016a6e4080; !peb 293d469000.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 lkd\u003e .process /p ffff9f016a6e4080; !peb 293d469000 Implicit process is now ffff9f01`6a6e4080 PEB at 000000293d469000 InheritedAddressSpace: No ReadImageFileExecOptions: No BeingDebugged: No ImageBaseAddress: 00007ff7fa6e0000 NtGlobalFlag: 0 NtGlobalFlag2: 0 Ldr 00007ff90a2fc4c0 Ldr.Initialized: Yes Ldr.InInitializationOrderModuleList: 000001e52e003e00 . 000001e558d8f240 Ldr.InLoadOrderModuleList: 000001e52e003f70 . 000001e558d8f220 Ldr.InMemoryOrderModuleList: 000001e52e003f80 . 000001e558d8f230 Base TimeStamp Module 7ff7fa6e0000 61735063 Oct 22 16:59:31 2021 C:\\Program Files\\WindowsApps\\Microsoft.WinDbg_1.2210.3001.0_x64__8wekyb3d8bbwe\\DbgX.Shell.exe 7ff90a190000 b5ced1c6 Aug 28 07:10:14 2066 C:\\Windows\\SYSTEM32\\ntdll.dll 7ff908360000 e35abded Nov 14 12:34:53 2090 C:\\Windows\\System32\\KERNEL32.DLL 7ff907aa0000 e7e53a4e Apr 14 07:59:26 2093 C:\\Windows\\System32\\KERNELBASE.dll 7ff909150000 90a2bc88 Nov 23 03:10:00 2046 C:\\Windows\\System32\\USER32.dll 7ff9081b0000 0dcd0213 May 03 13:26:59 1977 C:\\Windows\\System32\\win32u.dll 7ff90a0c0000 3ee1d71f Jun 07 05:14:23 2003 C:\\Windows\\System32\\GDI32.dll 7ff9078e0000 94124ede Sep 20 08:16:46 2048 C:\\Windows\\System32\\gdi32full.dll 7ff907d80000 39255ccf May 19 08:25:03 2000 C:\\Windows\\System32\\msvcp_win.dll 7ff907e20000 2bd748bf Apr 22 18:39:11 1993 C:\\Windows\\System32\\ucrtbase.dll Many other drivers and system components, by registering process-creation notifications, can choose to create their own data structure to store information on a per-process basis. The executive functions PsSetCreateProcessNotifyRoutineEx and PsSetCreateProcessNotifyRoutineEx2 allow this and are documented in WDK. This technique might find its use in AV, EDR/XDR implementations.\nYou can see the contents of nt!_EPROCESS structure in lkd (Kernel Debugger). dt nt!_EPROCESS lists all fields of nt!_EPROCESS structure and their offsets in hexadecimal. Here’s what it looks like -\u003e\n1 2 3 4 5 6 7 8 9 10 11 12 lkd\u003e dt nt!_EPROCESS +0x000 Pcb : _KPROCESS +0x438 ProcessLock : _EX_PUSH_LOCK +0x440 UniqueProcessId : Ptr64 Void ... +0x520 SectionBaseAddress : Ptr64 Void +0x528 Cookie : Uint4B +0x530 WorkingSetWatch : Ptr64 _PAGEFAULT_HISTORY ... +0xb8c MinimalTerminate : Pos 1, 1 Bit +0xb90 SyscallUsage : Uint4B +0xb90 SyscallUsageValues : Usually, you’ll find EPROCESS not nt!_EPROCESS that’s because in the kernel debugger, the latter is the symbol for the former, which is used for identification of functions, variables, and structures during debugging.\ndt (display type) also shows specific contents of one or multiple fields by typing their names following the structure name. Like so -\u003e\n1 2 lkd\u003e dt nt!_EPROCESS ProcessLock +0x438 ProcessLock : _EX_PUSH_LOCK In the output above, the command examines ProcessLock (_EX_PUSH_LOCK) field.\nTo see a list of kernel structures use dt nt!_*. Note that ntkrnlmp is the internal name of the 64-bit kernel.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lkd\u003e dt nt!_* ntkrnlmp!_LIST_ENTRY ntkrnlmp!_LIST_ENTRY ntkrnlmp!_SINGLE_LIST_ENTRY ntkrnlmp!_UNICODE_STRING ntkrnlmp!_STRING ntkrnlmp!_RTL_QUERY_REGISTRY_TABLE ntkrnlmp!_LARGE_INTEGER ntkrnlmp!_ULARGE_INTEGER ntkrnlmp!_RTL_BITMAP ntkrnlmp!_KFLOATING_SAVE ntkrnlmp!_EXT_SET_PARAMETERS_V0 ntkrnlmp!_POOL_TYPE ntkrnlmp!_EX_POOL_PRIORITY ntkrnlmp!_FAST_MUTEX ntkrnlmp!_EVENT_TYPE ... ntkrnlmp!_KINTERRUPT ... The last structure (in the snipped output above) is ntkrnlmp!_KINTERRUPT. This struct contains pointers to all Interrupt Service Routines (ISR) registered by the kernel. ISRs execute on the CPU whenever an Interrupt or Exception occurs. All ISRs are pointed to by something called an Interrupt Descriptor Table or IDT, which is a CPU-defined data structure. ISRs tell the CPU what code to execute when it encounters an interrupt.\nYou can view the contents of the IDT, including information on what trap handlers Windows has assigned to interrupts (including exceptions and IRQs), using the !idt command in lkd.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 lkd\u003e !idt Dumping IDT: fffff80219b1d000 00: fffff80216939100 nt!KiDivideErrorFaultShadow 01: fffff80216939180 nt!KiDebugTrapOrFaultShadow Stack = 0xFFFFF80219B219D0 02: fffff80216939240 nt!KiNmiInterruptShadow Stack = 0xFFFFF80219B217D0 ... 07: fffff802169394c0 nt!KiNpxNotAvailableFaultShadow 08: fffff80216939540 nt!KiDoubleFaultAbortShadow Stack = 0xFFFFF80219B213D0 09: fffff802169395c0 nt!KiNpxSegmentOverrunAbortShadow 0a: fffff80216939640 nt!KiInvalidTssFaultShadow 0b: fffff802169396c0 nt!KiSegmentNotPresentFaultShadow ... 61: fffff8021693a5c8 0xfffff80218355b20 (KINTERRUPT ffffb081807fec80) 62: fffff8021693a5d0 0xfffff802191df2a0 (KINTERRUPT ffffb081807fe640) ... e3: fffff8021693a9d8 nt!HalpInterruptDeferredRecoveryService (KINTERRUPT fffff80216d38f80) fd: fffff8021693aaa8 nt!HalpTimerProfileInterrupt (KINTERRUPT fffff80216d399a0) fe: fffff8021693aab0 nt!HalpPerfInterrupt (KINTERRUPT fffff80216d39640) Traps are a superset of Interrupts and Exceptions, a trap frame stores thread context and is a subset of the thread’s complete execution context. The kernel also treats system services as exceptions (although they are also technically system traps).\nThe IDT has 256 entries, each one of which points to an ISR. The interrupt vector is the index of a particular slot in the IDT. The nt!_KINTERRUPT structure represents a driver’s registration of an ISR for one of these vectors.\nUse the -r flag to recursively examine all structures within nt!_KINTERRUPT, a number after -r determines the depth of recursion.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 lkd\u003e dt nt!_KINTERRUPT -r +0x000 Type : Int2B +0x002 Size : Int2B +0x008 InterruptListEntry : _LIST_ENTRY +0x000 Flink : Ptr64 _LIST_ENTRY +0x000 Flink : Ptr64 _LIST_ENTRY +0x008 Blink : Ptr64 _LIST_ENTRY +0x008 Blink : Ptr64 _LIST_ENTRY +0x000 Flink : Ptr64 _LIST_ENTRY +0x008 Blink : Ptr64 _LIST_ENTRY +0x018 ServiceRoutine : Ptr64 unsigned char +0x020 MessageServiceRoutine : Ptr64 unsigned char +0x028 MessageIndex : Uint4B +0x030 ServiceContext : Ptr64 Void +0x038 SpinLock : Uint8B ... Note the repeated occurrence of Flink (struct _LIST_ENTRY *Flink) and Blink (struct _LIST_ENTRY *Blink) fields. This makes sense as the kernel uses a circular doubly linked-list, called ActiveProcessLink for internal data structures. Each field is of the type LIST_ENTRY (typedef struct _LIST_ENTRY LIST_ENTRY, *PLIST_ENTRY). Flink points to the next node, while Blink points to the previous one.\nAll nt!_EPROCESS structures are similarly linked to form ActiveProcessLink with the ListHead stored in nt!PsActiveProcessHead. !process displays information from nt!_EPROCESS structure.\nI noted that if recursion depth is increased to -r 4, it breaks the output -\u003e\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 lkd\u003e dt nt!_KINTERRUPT -r 4 +0x000 Type : ?? +0x002 Size : ?? +0x008 InterruptListEntry : _LIST_ENTRY +0x000 Flink : ???? +0x008 Blink : ???? +0x018 ServiceRoutine : ???? +0x020 MessageServiceRoutine : ???? +0x028 MessageIndex : ?? ... +0x0b0 IsrDpcStats : _ISRDPCSTATS +0x000 IsrTime : ?? +0x008 IsrTimeStart : ?? +0x010 IsrCount : ?? +0x018 DpcTime : ?? +0x020 DpcTimeStart : ?? +0x028 DpcCount : ?? +0x030 IsrActive : ?? +0x031 Reserved : [7] \"--- memory read error at address 0x00000000`000000e5 ---\" +0x038 DpcWatchdog : _ISRDPCSTATS_SEQUENCE +0x000 SequenceNumber : ?? +0x008 IsrTime : ?? +0x010 IsrCount : ?? +0x018 DpcTime : ?? +0x020 DpcCount : ?? +0x110 RedirectObject : ???? +0x118 Padding : [8] \"--- memory read error at address 0x00000000`0000011c ---\" Memory read error 0000000000000114 The (probable!) cause might be that the memory indicated by ?? is uncommitted or de-allocated. As a process’ memory remains virtual unless VirtualAlloc allocates memory and zero-initializes it.\nI encourage you to experiment with lkd to become familiar with the syntax. Here is the resource you might need.\nA process can be created using several WinAPI functions -\u003e\nCreateProcessA -\u003e Most basic function which attempts to create a process and its primary thread with the same access token as the creating process. If a different token is required, CreateProcessAsUser can be used.\nCreateProcessWithTokenW -\u003e Part of the advapi32.dll, it is similar to CreateProcessAsUser the difference being the privileges required for the caller.\nCreateProcessWithLogonW -\u003e A handy shortcut to log on with a given user’s credentials (user, domain, and password).\nAll of the above have different use cases but eventually, all execution paths lead to CreateProcessInternal which calls NtCreateUserProcess (part of) which makes the transition to kernel mode and continues the kernel mode part of the process creation with the same name. As the name suggests, NtCreateUserProcess creates a user process. A user cannot create a native process, such as smss.exe and csrss.exe, as CreateProcessInternal function will reject images with native subsystem image type.\nApart from NT Processes, the Kernel Executive supports additional processes, that are created bypassing WinAPI, such as Native processes, Minimal, or Pico Processes. These would be beyond the scope of this post.\nYou might be following along in a VM. If you are using VMware, you might notice performance slowdowns or hangs, which can get quite frustrating. There is a good way to get more performance!\nIf you’re using VMWare Player, make sure the VM is “Shut Down” and not “Suspended”. Then, navigate to the Virtual Machine working directory. Locate the config file .vmx. Open that in an editor and add the following line to it -\u003e ulm.disableMitigations = \"TRUE\". This will disable side-channel mitigations applied to your VM. If you’re using Workstation pro, then you can directly disable side-channel mitigations in “Edit Virtual Machine Settings”. Threads A thread is a subcomponent of a process that does the actual execution. A process contains threads (at a minimum, 1 thread). Threads have their address space isolated from each other and share a common address space of the process. At OS-level, a Windows thread is represented by an executive thread object. This object encapsulates nt!_ETHREAD (which is also an opaque kernel structure) which contains, among others, nt!_KTHREAD structure as its first member. nt!_KTHREAD points to several other structures all of which reside in system address space, with the exception of Thread Environment Block (TEB). TEB, like PEB, resides in userspace.\nThe Windows subsystem process (csrss) maintains a parallel data structure CSR_THREAD. For threads that have called a Windows subsystem USER or GDI function, the kernel-mode portion of the Windows Subsystem (Win32k.sys) maintains a per-thread data structure (W32THREAD) that the KTHREAD structure points to.\nThe simplest function to create a thread is CreateThread function which creates a thread in the current process. On successful completion, a non-zero handle is returned, and a unique thread ID if requested by the caller.\nCreateRemoteThread is used to inject a thread into another process. It can be used by the debugger to force a break in a debugged process. The debugger injects the thread which immediately causes a breakpoint by calling the DebugBreak function. Another use can be to obtain information about a process when running within the target process context, this can be done for legitimate or malicious purposes.\nGoing back to lkd, you can use it to examine nt!_ETHREAD -\u003e\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lkd\u003e dt nt!_ETHREAD +0x000 Tcb : _KTHREAD +0x480 CreateTime : _LARGE_INTEGER +0x488 ExitTime : _LARGE_INTEGER +0x488 KeyedWaitChain : _LIST_ENTRY +0x498 PostBlockList : _LIST_ENTRY ... +0x560 DisableDynamicCodeOptOut : Pos 18, 1 Bit +0x560 ExplicitCaseSensitivity : Pos 19, 1 Bit +0x560 PicoNotifyExit : Pos 20, 1 Bit +0x560 DbgWerUserReportActive : Pos 21, 1 Bit +0x560 ForcedSelfTrimActive : Pos 22, 1 Bit +0x560 SamplingCoverage : Pos 23, 1 Bit ... +0x6b8 LastExpectedRunTime : Uint4B +0x6bc LastSoftParkElectionRunTime : Uint4B +0x6c0 LastSoftParkElectionGeneration : Uint8B +0x6c8 LastSoftParkElectionGroupAffinity : _GROUP_AFFINITY +0x6d8 UpdateTebListEntry : _SINGLE_LIST_ENTRY Listed above are the structures inside nt!_ETHREAD and their types. For instance, Tcb is of type _KTHREAD, and CreateTime is an instance of _LARGE_INTEGER structure.\n!thread can be used to view information about a thread. But this can only be used in kernel-mode debugging.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 lkd\u003e !thread THREAD ffff830869dec080 Cid 24cc.0250 Teb: 0000003a3cb00000 Win32Thread: ffff83086dfe3da0 WAIT: (WrUserRequest) UserMode Non-Alertable ffff83086fb5f280 QueueObject IRP List: ffff83086eac8ba0: (0006,0358) Flags: 00060800 Mdl: 00000000 Not impersonating DeviceMap ffffe586f8dcf270 Owning Process ffff83086fea80c0 Image: DbgX.Shell.exe Attached Process N/A Image: N/A Wait Start TickCount 5303564 Ticks: 748 (0:00:00:11.687) Context Switch Count 2299901 IdealProcessor: 1 UserTime 00:05:51.000 KernelTime 00:03:42.062 Win32 Start Address 0x00007ff678783d50 Stack Init ffff960b2293ac70 Current ffff960b2293a050 Base ffff960b2293b000 Limit ffff960b22935000 Call 0000000000000000 Priority 12 BasePriority 8 PriorityDecrement 2 IoPriority 2 PagePriority 5 Unable to get context for thread running on processor 1, HRESULT 0x80004001 The 64-bit hexadecimal number after THREAD is the address of ETHREAD block.\nTwo 16-bit hexadecimal numbers after Cid are of the form processID.threadID, processID is 0x24cc and threadID is 0x0250 in this case.\nThe 64-bit hexadecimal number after Teb is the address of Thread Environment Block (TEB).\nThe 64-bit hexadecimal number after Win32Thread is the address of Win32Thread.\nApart from these, other fields show stack trace, priority, thread start address, owning process, and thread state.\nVirtual Memory It is what is written on the box, a memory that doesn’t exists (but is mapped). When a processor writes to a memory location it writes to a virtual address. The essence of virtual memory lies in the fact that from an execution perspective, the CPU doesn’t need to know whether the memory is mapped to RAM or Disk.\nBelow is the layout for two “extreme” cases: a 32-bit process on a 32-bit system (left) and a 64-bit process on a 64-bit system (right) -\u003e\nVirtual Memory Layout in Different Cases, Source: Windows Kernel Programming, 2nd Edition.\nIf the requested page doesn’t exist in RAM, the CPU raises a page fault exception, which causes the memory manager’s page fault exception handler to fetch data from the file (if it’s a valid page fault), copy it to RAM, update the page table entries and instruct CPU to try again.\nWindows also supports large pages, by using Page Directory Entry (PDE) to directly map a large page without using a page table. This makes better use of Translation Lookaside Buffer (TLB) - a cache of recently translated pages maintained by the CPU.\nA non-paged area is a memory region that is guaranteed to remain in memory as it’s never paged. But the Windows Bug Check error PAGE_FAULT_IN_NONPAGED_AREA (0x00000050) seemingly contradicts this idea that a page fault cannot happen in a region where the referenced memory is guaranteed to be in RAM. Interesting! A probable cause for this might be a situation where a driver misuses non-paged pool allocations and/or references invalid memory. Bad driver code or corrupt system memory is the major reason almost all the time.\nMode of Execution This refers to the nature of the code being executed. Does that belong to a user application or a part of a kernel component? The nature of code determines the privilege assigned to it. To support this structure, x64 processors are divided into privilege levels/rings -\u003e Ring 3 to Ring 0. The purpose is to differentiate system and user data, and to protect it from inadvertent/malicious access or writes.\nThese rings go even deeper in modern Intel/AMD Processors -\u003e\nRing -1: Hypervisor Ring -2: System Management Mode (SMM) Ring -3: Intel Management Engine (ME). With a special emphasis, this sub-component is downright dystopian. To understand why, I highly encourage you go to through the post -\u003e Negative Rings in Intel Architecture: The Security Threats That You’ve Probably Never Heard Of on Medium by RealWorldCyberSecurity. Below these exist the Microcode (which is a layer between CPU hardware and programmer visible ISA) and the actual Silicon.\nWhen a user launches an application, Windows creates a private virtual address space and a private handle table (more on this later). Each page in Virtual Memory is tagged to indicate what access mode the processor must be in to read/or write the page. A user-mode application has its own private address space isolated from other processes and the OS. So, if a process crashes, it doesn’t affect other processes, they keep running.\nA kernel mode component, such as a Kernel-Mode driver, shares its address space with the whole kernel. This implies if a component crashes it takes the whole system with it. The kernel, Hardware Abstraction Layer (HAL), and kernel drivers operate in kernel space.\nSystem Services Or System Calls are used to request kernel services like reading from the file, thread creation, etc. System calls in Windows follow a rather complex path as compared to Unix syscalls. Under Windows, user applications don’t call the native Windows OS services directly. Rather, they go through one or more subsystem Dynamic-Link Libraries (DLLs).\nTake file creation for example.\nWhen a user creates a new file in Notepad, its code calls CreateFile, which is documented, and implemented in kernel32.dll. This function runs in user mode, so there is no way it can open a file. After some error checking, it calls NtCreateFile, a function implemented in ntdll.dll. It is documented and is the one that makes the actual transition to kernel mode. Before the transition, it puts a number called System Service Number, into a CPU register (EAX on Intel/AMD architectures). Then it issues a special CPU instruction (syscallon on x64 or sysenter on x86) that makes the actual transition to kernel mode while jumping to a predefined routine called the System Service Dispatcher (SSD). The SSD, in turn, uses the value in the EAX register as an index into a System Service Dispatch Table (SSDT). Using this table, the code jumps to the system service (call) itself. For the Notepad example, the SSDT entry would point to NtCreateFile, implemented by the kernel I/O manager.\nThis can be seen in action. Open Notepad.exe in ‘WinDbg Preview’. Upon attaching to the process, the debugger will hit a default breakpoint -\u003e\n1 2 3 (6b4.840): Break instruction exception - code 80000003 (first chance) ntdll!LdrpDoDebuggerBreak+0x30: 00007ff8`fac8c0e0 cc int 3 Set a breakpoint in NtCreateFile inside ntdll.dll using bp ntdll!ntcreatefile. Then type g (go) to continue execution. The newly set breakpoint will hit almost immediately.\n1 2 3 4 ... Breakpoint 0 hit ntdll!NtCreateFile: 00007ff8`fac50320 4c8bd1 mov r10,rcx Enter u (unassembled) command to see a few instructions ahead -\u003e\n1 2 3 4 5 6 7 8 9 10 0:000\u003e u ntdll!NtCreateFile: 00007ff8`fac50320 4c8bd1 mov r10,rcx 00007ff8`fac50323 b855000000 mov eax,55h 00007ff8`fac50328 f604250803fe7f01 test byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],1 00007ff8`fac50330 7503 jne ntdll!NtCreateFile+0x15 (00007ff8`fac50335) 00007ff8`fac50332 0f05 syscall 00007ff8`fac50334 c3 ret 00007ff8`fac50335 cd2e int 2Eh 00007ff8`fac50337 c3 ret As mentioned above, EAX is set with SSN -\u003e 0x55. This is the system call number. Then notice the syscall instruction. This switches the processor to kernel mode, jumping to the SSDT entry corresponding to the value inside EAX. Predictably, 0x55 corresponds to NtCreateFile. Notice the flag value set to 1 at offset 0x308 to SharedUserData. If this flag is set, the execution will take another path using the int 2Eh instruction on the second to last line of the output above. This flag corresponds to a specific Credential Guard VBS (Virtualization Based Security) feature as the hypervisor can better react to int instruction rather than syscall.\nAll right! Enough for this one!\nObjects and Handles In Windows, an object is a single, runtime instance of a statically defined object. They are kernel data structures representing commonly used facilities like files, registry keys, processes, threads, devices, etc. that are managed by the Object Manager, a component of the Windows Kernel. Not all objects have names, for eg., processes and threads don’t have names - they have IDs. That’s why the OpenProcess() and OpenThread() functions require a process/thread identifier (a number) rather than a string-base name.\nWindows has three primary types of objects: Executive Objects, Kernel Objects, and GDI/User Objects.\nObject categorization, Source: Windows Internals, Part 1.\nExecutive objects are implemented by various components of the executive (such as process manager, memory manager, and I/O subsystem). Kernel objects are a more primitive set of objects implemented by the Windows kernel. These objects are not visible to user-mode code but are created and used only within the executive. Majority of GDI/User objects belong to the Windows subsystem (Win32k.sys) and do not interact with the kernel. WinObj tool from Sysinternals displays all objects in the system.\nAll GLOBAL$$ objects as viewed in WinObj.\nAll such objects are preceded by an nt!_OBJECT_HEADER structure that contains information about the object and is used to manage the life cycle of the object, allow it to be uniquely named, and secure it by applying access control, invoke the object type-specific methods and track the allocator’s quota usage.\nHandles are references returned to the caller by the callee (APIs in this case) that are then translated to pointers by WDF. Processes in Windows have their own handle table which is stored in the kernel virtual address space. Handles are always a multiple of 4, and 0 is never a valid handle value.\nThe kernel (and driver) code can either work with a handle or pointer to an object. Handles can be converted to points using ObDereferenceObjectByHandle() and ObReferenceObjectByHandle() functions. The former function returns a pointer to the object and the latter function increments the reference count of the object. The reference count is decremented when the object is no longer needed. The object is freed when the reference count reaches 0. Object manager destroys the object if its reference count reaches 0.\nnt!_HANDLE_TABLE_ENTRY represents an individual entry in the process handle table. Handle tables are allocated from Paged Pool. When a process terminates the function ExSweepHandleTable() closes all handles in the handle table of that process.\n!handle can be used to examine the handle table of the currently running process. The output would be huge!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 lkd\u003e !handle PROCESS ffff9f016a6e4080 SessionId: 1 Cid: 067c Peb: 293d469000 ParentCid: 09bc DirBase: 5bb72002 ObjectTable: ffffcd04ce0bdd00 HandleCount: 754. Image: DbgX.Shell.exe Handle table at ffffcd04ce0bdd00 with 758 entries in use 0004: Object: ffff9f016aef20e0 GrantedAccess: 001f0003 (Protected) (Inherit) Entry: ffffcd04cd8f7010 Object: ffff9f016aef20e0 Type: (ffff9f01638b30c0) Event ObjectHeader: ffff9f016aef20b0 (new version) HandleCount: 1 PointerCount: 32768 0008: Object: ffff9f016aef1be0 GrantedAccess: 001f0003 (Protected) (Inherit) Entry: ffffcd04cd8f7020 Object: ffff9f016aef1be0 Type: (ffff9f01638b30c0) Event ObjectHeader: ffff9f016aef1bb0 (new version) HandleCount: 1 PointerCount: 32755 000c: Object: ffff9f016abbeee0 GrantedAccess: 00000001 (Protected) (Inherit) Entry: ffffcd04cd8f7030 Object: ffff9f016abbeee0 Type: (ffff9f01638c2380) WaitCompletionPacket ObjectHeader: ffff9f016abbeeb0 (new version) HandleCount: 1 PointerCount: 32755 The output displays the handle table of the current process and properties of individual handles, including a total of 758 entries. The HandleCount field shows 754 entries, but the OS allocates additional handles for improved performance, resulting in 758 entries in the table.\nSubsystems, Subsystem DLLs and ntdll.dll A subsystem is a facility by which Windows exposes some subset of the base Windows executive system services to application programs.\nThis means that some things that can be done from an application built on one subsystem can’t be done by another application built on another subsystem. Each executable image .exe is bound to only one subsystem. Subsystems are started by the Session Manager (Smss.exe) process. Subsystem startup information is stored under the registry key HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\SubSystems\nDuring process creation, the process creation code examines the sub-system type header code and notifies the target subsystem of the new process. This type of code is defined in the /SUBSYSTEM linker flag of Visual Studio Linker.\nYou can view the image subsystem type using the Dependency Walker (depends.exe). If you check notepad.exe -\u003e\nDependency Listing of Notepad.exe in depends.exe.\nThe role of subsystem DLLs is to translate a documented function into the appropriate internal (and generally undocumented) native system service calls implemented mostly in NTDLL.DLL.\nNTDLL.DLL comprises the lowest layer of code that still runs in user mode. It acts as a special support library primarily for the use of subsystem DLLs and native applications. Native images are those images that are not tied to any particular subsystem.\nHardware Abstraction Layer (HAL) The HAL is a loadable kernel-mode module (Hal.dll) that provides the low-level interface to the hardware platform on which Windows is running. This is a layer of code that isolates the kernel, the device drivers, and the rest of the Windows Executive from platform-specific hardware differences.\nIt hides hardware-dependent details such as I/O interfaces, interrupt controllers, and multiprocessor communication mechanisms — any functions that are both architecture-specific and machine-dependent. So rather than access hardware directly, Windows internal components and user-written device drivers maintain portability by calling the HAL routines when they need platform-dependent information. For this reason, many HAL routines are documented in the WDK.\nHyper-V Hypervisor and Driver Code Security Challenges This contains the hypervisor. There are no drivers or other modules in this environment. That being said, the hypervisor itself is composed of multiple internal layers and services, such as its own Memory Manager, Virtual Processor scheduler, Interrupt and Time management, Synchronization Routines, Partitions (VM instances) management, and Inter-Partition Communication (IPC), and more. This is one level below Ring 0 privilege, Ring -1.\nOne of the main roles of Hyper-V in Windows 10 and Windows Server 2016 (and later) is to enable support for Virtualization Based Security (VBS).\nVBS provides an extra layer of security as the normal OS exists as a Hyper-V VM. Windows uses Virtual Trust Levels (VTLs), which use the hypervisor to configure virtual trust levels. This is to address challenges arising from malicious driver code which could access kernel-mode memory.\nVBS provides extra security on top of processor isolation.\nConclusion and Credits In this post, you learned about Windows Processes, Threads, System Services, and other specific topics like Virtual Memory, Objects, and Handles.\nIn the next post, you’ll start building your first driver. All the subsequent posts will lay more emphasis on the driver development process and would be code intensive.\nStay Tuned!\nTx0actical. Out.\nThis post draws inspiration from Windows Internals, if you wish to dive even deeper (The book, for instance, explains Session Manager, smss.exe in 38 points!), Windows Kernel Programming, the official Microsoft documentation and my experimentation. Also, if you wish to dive deeper into Windows Internals for security research, I would highly recommend CodeMachine, they provide training for all things “Windows Security”. Some of their articles have also inspired this post.\n","wordCount":"4881","inLanguage":"en","image":"https://Tx0actical.github.io/images/Lissajous_curve_5by4.svg","datePublished":"2023-03-24T12:53:24+05:30","dateModified":"2023-03-24T12:53:24+05:30","author":{"@type":"Person","name":"Tx0actical"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://Tx0actical.github.io/posts/win-drivers/win-drivers-p2/"},"publisher":{"@type":"Organization","name":"Tx0actical's Blog","logo":{"@type":"ImageObject","url":"https://Tx0actical.github.io/favicon_io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Tx0actical.github.io/ accesskey=h title="Tx0actical (Alt + H)">Tx0actical</a></div><div style=display:flex;flex-direction:row><ul id=menu><li><a href=https://Tx0actical.github.io/about/ title=About><span>About</span></a></li><li><a href=https://Tx0actical.github.io/writeups title=Writeups><span>Writeups</span></a></li><li><a href=https://Tx0actical.github.io/win-drivers title=Drivers><span>Drivers</span></a></li><li><a href=https://Tx0actical.github.io/projects title=Projects><span>Projects</span></a></li></ul><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Tx0actical.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://Tx0actical.github.io/posts/>Posts</a></div><h1 class=post-title>0x02 Advanced Windows Internals</h1><div class=post-description>Writing Windows KMDF Drivers for Fun and Exploitation - Part 2</div><div class=post-meta><span title='2023-03-24 12:53:24 +0530 IST'>March 24, 2023</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;4881 words&nbsp;·&nbsp;Tx0actical&nbsp;|&nbsp;<a href=https://github.com/Tx0actical/Tx0actical.github.io/pulls rel="noopener noreferrer" target=_blank>Suggestions?</a></div></header><figure class=entry-cover><img loading=lazy src=https://Tx0actical.github.io/images/Lissajous_curve_5by4.svg alt="Lissajous Curve"><p><a href="https://commons.wikimedia.org/w/index.php?curid=1484162">Lissajous Curve</a> By Alessio Damato</p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#processes>Processes</a></li><li><a href=#threads>Threads</a></li><li><a href=#virtual-memory>Virtual Memory</a></li><li><a href=#mode-of-execution>Mode of Execution</a></li><li><a href=#system-services>System Services</a></li><li><a href=#objects-and-handles>Objects and Handles</a></li><li><a href=#subsystems-subsystem-dlls-and-ntdlldll>Subsystems, Subsystem DLLs and ntdll.dll</a></li><li><a href=#hardware-abstraction-layer-hal>Hardware Abstraction Layer (HAL)</a></li><li><a href=#hyper-v-hypervisor-and-driver-code-security-challenges>Hyper-V Hypervisor and Driver Code Security Challenges</a></li><li><a href=#conclusion-and-credits>Conclusion and Credits</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Hello.</p><p>KMDF (or WDF for that matter) being a Windows thing, you need to understand some Windows fundamentals.</p><p>In this iteration, Part 2, of &ldquo;Writing Windows KMDF Drivers for Fun and Profit&rdquo;, I&rsquo;ll introduce you to important Windows Concepts such as Processes, Threads, Virtual Memory, System Services, Objects and Handles, Subsystems, and the Hyper-V Hypervisor. You&rsquo;ll discover these constructs in great detail in this post. This post is informational and explorational in nature and can be treated as a reference, if you will.</p><p>With this, I wanted to focus on experimentation and a deep-dive explanation and do something different instead of replaying information that already exists. Output of various debugger commands are snipped indicated by a <code>...</code> for the sake of brevity.</p><p>Anyone who&rsquo;s ever dug a little deep about Windows might be familiar with this image:</p><figure class=align-center><img loading=lazy src=/images/WinArch.png#center alt="Object categorization in Windows"><figcaption><p>General Architecture, Source: Windows Internals, Part 1.</p></figcaption></figure><p>We&rsquo;ll now examine this architecture in detail.</p><h3 id=processes>Processes<a hidden class=anchor aria-hidden=true href=#processes>#</a></h3><p>A process is a management and containment object which represents an instance of a program. Contrary to popular belief, processes don&rsquo;t run, they &ldquo;manage&rdquo;. Each Windows process is defined by an executive process structure or <code>nt!_EPROCESS</code>. This structure (<code>typedef struct _EPROCESS EPROCESS, *PEPROCESS</code> to be exact) is the kernel&rsquo;s representation of a process object. It exists only in kernel memory, user-mode can access indirectly through handles (handles are explained later). The Windows kernel maintains a <code>nt!_EPROCESS</code> structure for every process including -> System Idle Process (PID 0) and System (Process) (PID 4).</p><p>It is an <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/eprocess>opaque kernel structure</a> defined as -></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_EPROCESS</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span> <span class=c1>// Opaque
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>EPROCESS</span><span class=p>,</span> <span class=o>*</span><span class=n>PEPROCESS</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><code>nt!_EPROCESS</code> and its constituent data structures are contained in the System address space and can be examined from kernel mode, except for <strong>Process Control Block</strong> (PCB) which exists in User space.</p><p>Moreover, the subsystem service <code>csrss.exe</code> maintains a parallel data structure <code>CSR_PROCESS</code>. Additionally, the kernel mode part of the subsystem <code>Win32k.sys</code> maintains a per-process data structure, <code>W32PROCESS</code>. Except for the <code>idle</code> process, every process has a process object associated with it.</p><blockquote><p>This post introduces you to the Kernel Debugger. It is a useful tool to examine internal components. To get started, you&rsquo;ll need to -></p><ol><li>Enable debugging. To do that, in an elevated command prompt, type <code>bcdedit /debug on</code> and restart.</li><li>If secure boot is enabled, might need to do additional changes in the boot menu (You can avoid the hassle of tinkering with BIOS options. Instead, use a VM. Follow the above-mentioned steps, and you&rsquo;ll be good to go).</li><li>Install &ldquo;WinDbg Preview&rdquo; from Microsoft Store.</li><li>After it&rsquo;s installed, go to &lsquo;Home&rsquo; ->
&lsquo;Attach to kernel&rsquo; -> <em>Select</em> &lsquo;Local&rsquo;. This will start a Local Kernel Debugging Session.</li><li>Once there, you can type all the commands in <code>lkd</code> in the command window.</li></ol></blockquote><p>To see all processes, use <code>!process 0 0</code> in the Kernel Debugger. But the output would be huge. Instead, we&rsquo;ll use <code>!process</code> with no arguments which will list information for the process owning the thread that is currently executing on CPU 0, or the current Debugging process.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lkd&gt; !process
</span></span><span class=line><span class=cl>PROCESS ffff9f016a6e4080
</span></span><span class=line><span class=cl>    SessionId: 1  Cid: 067c    Peb: 293d469000  ParentCid: 09bc
</span></span><span class=line><span class=cl>    DirBase: 5bb72002  ObjectTable: ffffcd04ce0bdd00  HandleCount: 700.
</span></span><span class=line><span class=cl>    Image: DbgX.Shell.exe
</span></span><span class=line><span class=cl>    VadRoot ffff9f016a9c0450 Vads 697 Clone 0 Private 36707. Modified 1193. Locked 10123.
</span></span><span class=line><span class=cl>    DeviceMap ffffcd04cb15b170
</span></span><span class=line><span class=cl>    Token                             ffffcd04ce048770
</span></span><span class=line><span class=cl>    ElapsedTime                       00:14:32.628
</span></span><span class=line><span class=cl>    UserTime                          00:00:11.062
</span></span><span class=line><span class=cl>    KernelTime                        00:00:02.484
</span></span><span class=line><span class=cl>    QuotaPoolUsage[PagedPool]         689520
</span></span><span class=line><span class=cl>    QuotaPoolUsage[NonPagedPool]      95456
</span></span><span class=line><span class=cl>    Working Set Sizes (now,min,max)  (58644, 50, 345) (234576KB, 200KB, 1380KB)
</span></span><span class=line><span class=cl>    PeakWorkingSetSize                68423
</span></span><span class=line><span class=cl>    VirtualSize                       2102310 Mb
</span></span><span class=line><span class=cl>    PeakVirtualSize                   2102367 Mb
</span></span><span class=line><span class=cl>    PageFaultCount                    206265
</span></span><span class=line><span class=cl>    MemoryPriority                    FOREGROUND
</span></span><span class=line><span class=cl>    BasePriority                      8
</span></span><span class=line><span class=cl>    CommitCharge                      40393
</span></span><span class=line><span class=cl>    Job                               ffff9f016a4a3060
</span></span></code></pre></td></tr></table></div></div><p>This returns the address of <strong>Process Environment Block</strong> (PEB) which is the user-mode representation of the process. It contains the information by image loader, heap manager, and other Windows components that need access to it from user mode. This corresponds to the image -> <code>DbgX.Shell.exe</code> (which is the current debug shell process). To examine its <code>peb</code> we need to switch the current context to that process, this can be done using <code>.process /p</code> with the process address, <code>0xffff9f016a6e4080</code> in this case. Then examine the <code>peb</code> using <code>!peb</code> with the address passed as a parameter, which is <code>0x293d469000</code>. The complete command is -> <code>.process /p ffff9f016a6e4080; !peb 293d469000</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lkd&gt; .process /p ffff9f016a6e4080; !peb 293d469000
</span></span><span class=line><span class=cl>Implicit process is now ffff9f01`6a6e4080
</span></span><span class=line><span class=cl>PEB at 000000293d469000
</span></span><span class=line><span class=cl>    InheritedAddressSpace:    No
</span></span><span class=line><span class=cl>    ReadImageFileExecOptions: No
</span></span><span class=line><span class=cl>    BeingDebugged:            No
</span></span><span class=line><span class=cl>    ImageBaseAddress:         00007ff7fa6e0000
</span></span><span class=line><span class=cl>    NtGlobalFlag:             0
</span></span><span class=line><span class=cl>    NtGlobalFlag2:            0
</span></span><span class=line><span class=cl>    Ldr                       00007ff90a2fc4c0
</span></span><span class=line><span class=cl>    Ldr.Initialized:          Yes
</span></span><span class=line><span class=cl>    Ldr.InInitializationOrderModuleList: 000001e52e003e00 . 000001e558d8f240
</span></span><span class=line><span class=cl>    Ldr.InLoadOrderModuleList:           000001e52e003f70 . 000001e558d8f220
</span></span><span class=line><span class=cl>    Ldr.InMemoryOrderModuleList:         000001e52e003f80 . 000001e558d8f230
</span></span><span class=line><span class=cl>                    Base TimeStamp                     Module
</span></span><span class=line><span class=cl>            7ff7fa6e0000 61735063 Oct 22 16:59:31 2021 C:\Program Files\WindowsApps\Microsoft.WinDbg_1.2210.3001.0_x64__8wekyb3d8bbwe\DbgX.Shell.exe
</span></span><span class=line><span class=cl>            7ff90a190000 b5ced1c6 Aug 28 07:10:14 2066 C:\Windows\SYSTEM32\ntdll.dll
</span></span><span class=line><span class=cl>            7ff908360000 e35abded Nov 14 12:34:53 2090 C:\Windows\System32\KERNEL32.DLL
</span></span><span class=line><span class=cl>            7ff907aa0000 e7e53a4e Apr 14 07:59:26 2093 C:\Windows\System32\KERNELBASE.dll
</span></span><span class=line><span class=cl>            7ff909150000 90a2bc88 Nov 23 03:10:00 2046 C:\Windows\System32\USER32.dll
</span></span><span class=line><span class=cl>            7ff9081b0000 0dcd0213 May 03 13:26:59 1977 C:\Windows\System32\win32u.dll
</span></span><span class=line><span class=cl>            7ff90a0c0000 3ee1d71f Jun 07 05:14:23 2003 C:\Windows\System32\GDI32.dll
</span></span><span class=line><span class=cl>            7ff9078e0000 94124ede Sep 20 08:16:46 2048 C:\Windows\System32\gdi32full.dll
</span></span><span class=line><span class=cl>            7ff907d80000 39255ccf May 19 08:25:03 2000 C:\Windows\System32\msvcp_win.dll
</span></span><span class=line><span class=cl>            7ff907e20000 2bd748bf Apr 22 18:39:11 1993 C:\Windows\System32\ucrtbase.dll
</span></span></code></pre></td></tr></table></div></div><p>Many other drivers and system components, by registering process-creation notifications, can choose to create their own data structure to store information on a per-process basis. The executive functions <code>PsSetCreateProcessNotifyRoutineEx</code> and <code>PsSetCreateProcessNotifyRoutineEx2</code> allow this and are documented in WDK. This technique might find its use in AV, EDR/XDR implementations.</p><p>You can see the contents of <code>nt!_EPROCESS</code> structure in <code>lkd</code> (Kernel Debugger). <code>dt nt!_EPROCESS</code> lists all fields of <code>nt!_EPROCESS</code> structure and their offsets in hexadecimal. Here&rsquo;s what it looks like -></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lkd&gt; dt nt!_EPROCESS
</span></span><span class=line><span class=cl>   +0x000 Pcb              : _KPROCESS
</span></span><span class=line><span class=cl>   +0x438 ProcessLock      : _EX_PUSH_LOCK
</span></span><span class=line><span class=cl>   +0x440 UniqueProcessId  : Ptr64 Void
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   +0x520 SectionBaseAddress : Ptr64 Void
</span></span><span class=line><span class=cl>   +0x528 Cookie           : Uint4B
</span></span><span class=line><span class=cl>   +0x530 WorkingSetWatch  : Ptr64 _PAGEFAULT_HISTORY
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   +0xb8c MinimalTerminate : Pos 1, 1 Bit
</span></span><span class=line><span class=cl>   +0xb90 SyscallUsage     : Uint4B
</span></span><span class=line><span class=cl>   +0xb90 SyscallUsageValues : &lt;unnamed-tag&gt;
</span></span></code></pre></td></tr></table></div></div><blockquote><p>Usually, you&rsquo;ll find <code>EPROCESS</code> not <code>nt!_EPROCESS</code> that&rsquo;s because in the kernel debugger, the latter is the symbol for the former, which is used for identification of functions, variables, and structures during debugging.</p></blockquote><p><code>dt</code> (display type) also shows specific contents of one or multiple fields by typing their names following the structure name. Like so -></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lkd&gt; dt nt!_EPROCESS ProcessLock
</span></span><span class=line><span class=cl>   +0x438 ProcessLock : _EX_PUSH_LOCK
</span></span></code></pre></td></tr></table></div></div><p>In the output above, the command examines <code>ProcessLock</code> (<code>_EX_PUSH_LOCK</code>) field.</p><p>To see a list of kernel structures use <code>dt nt!_*</code>. Note that <code>ntkrnlmp</code> is the internal name of the 64-bit kernel.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lkd&gt; dt nt!_*
</span></span><span class=line><span class=cl>   ntkrnlmp!_LIST_ENTRY
</span></span><span class=line><span class=cl>   ntkrnlmp!_LIST_ENTRY
</span></span><span class=line><span class=cl>   ntkrnlmp!_SINGLE_LIST_ENTRY
</span></span><span class=line><span class=cl>   ntkrnlmp!_UNICODE_STRING
</span></span><span class=line><span class=cl>   ntkrnlmp!_STRING
</span></span><span class=line><span class=cl>   ntkrnlmp!_RTL_QUERY_REGISTRY_TABLE
</span></span><span class=line><span class=cl>   ntkrnlmp!_LARGE_INTEGER
</span></span><span class=line><span class=cl>   ntkrnlmp!_ULARGE_INTEGER
</span></span><span class=line><span class=cl>   ntkrnlmp!_RTL_BITMAP
</span></span><span class=line><span class=cl>   ntkrnlmp!_KFLOATING_SAVE
</span></span><span class=line><span class=cl>   ntkrnlmp!_EXT_SET_PARAMETERS_V0
</span></span><span class=line><span class=cl>   ntkrnlmp!_POOL_TYPE
</span></span><span class=line><span class=cl>   ntkrnlmp!_EX_POOL_PRIORITY
</span></span><span class=line><span class=cl>   ntkrnlmp!_FAST_MUTEX
</span></span><span class=line><span class=cl>   ntkrnlmp!_EVENT_TYPE
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   ntkrnlmp!_KINTERRUPT
</span></span><span class=line><span class=cl>   ...
</span></span></code></pre></td></tr></table></div></div><p>The last structure (in the snipped output above) is <code>ntkrnlmp!_KINTERRUPT</code>. This <code>struct</code> contains pointers to all <strong>Interrupt Service Routines</strong> (ISR) registered by the kernel. ISRs execute on the CPU whenever an Interrupt or Exception occurs. All ISRs are pointed to by something called an <strong>Interrupt Descriptor Table</strong> or IDT, which is a CPU-defined data structure. ISRs tell the CPU what code to execute when it encounters an interrupt.</p><p>You can view the contents of the IDT, including information on what trap handlers Windows has assigned to interrupts (including exceptions and IRQs), using the <code>!idt</code> command in <code>lkd</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lkd&gt; !idt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   Dumping IDT: fffff80219b1d000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   00:   fffff80216939100 nt!KiDivideErrorFaultShadow
</span></span><span class=line><span class=cl>   01:   fffff80216939180 nt!KiDebugTrapOrFaultShadow Stack = 0xFFFFF80219B219D0
</span></span><span class=line><span class=cl>   02:   fffff80216939240 nt!KiNmiInterruptShadow  Stack = 0xFFFFF80219B217D0
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   07:   fffff802169394c0 nt!KiNpxNotAvailableFaultShadow
</span></span><span class=line><span class=cl>   08:   fffff80216939540 nt!KiDoubleFaultAbortShadow Stack = 0xFFFFF80219B213D0
</span></span><span class=line><span class=cl>   09:   fffff802169395c0 nt!KiNpxSegmentOverrunAbortShadow
</span></span><span class=line><span class=cl>   0a:   fffff80216939640 nt!KiInvalidTssFaultShadow
</span></span><span class=line><span class=cl>   0b:   fffff802169396c0 nt!KiSegmentNotPresentFaultShadow
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   61:   fffff8021693a5c8 0xfffff80218355b20 (KINTERRUPT ffffb081807fec80)
</span></span><span class=line><span class=cl>   62:   fffff8021693a5d0 0xfffff802191df2a0 (KINTERRUPT ffffb081807fe640)
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   e3:   fffff8021693a9d8 nt!HalpInterruptDeferredRecoveryService (KINTERRUPT fffff80216d38f80)
</span></span><span class=line><span class=cl>   fd:   fffff8021693aaa8 nt!HalpTimerProfileInterrupt (KINTERRUPT fffff80216d399a0)
</span></span><span class=line><span class=cl>   fe:   fffff8021693aab0 nt!HalpPerfInterrupt (KINTERRUPT fffff80216d39640)
</span></span></code></pre></td></tr></table></div></div><blockquote><p>Traps are a superset of Interrupts and Exceptions, a trap frame stores thread context and is a subset of the thread&rsquo;s complete execution context. The kernel also treats system services as exceptions (although they are also technically system traps).</p></blockquote><p>The IDT has 256 entries, each one of which points to an ISR. The interrupt vector is the index of a particular slot in the IDT. The <code>nt!_KINTERRUPT</code> structure represents a driver&rsquo;s registration of an ISR for one of these vectors.</p><p>Use the <code>-r</code> flag to recursively examine all structures within <code>nt!_KINTERRUPT</code>, a number after <code>-r</code> determines the depth of recursion.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lkd&gt; dt nt!_KINTERRUPT -r
</span></span><span class=line><span class=cl>   +0x000 Type             : Int2B
</span></span><span class=line><span class=cl>   +0x002 Size             : Int2B
</span></span><span class=line><span class=cl>   +0x008 InterruptListEntry : _LIST_ENTRY
</span></span><span class=line><span class=cl>      +0x000 Flink            : Ptr64 _LIST_ENTRY
</span></span><span class=line><span class=cl>         +0x000 Flink            : Ptr64 _LIST_ENTRY
</span></span><span class=line><span class=cl>         +0x008 Blink            : Ptr64 _LIST_ENTRY
</span></span><span class=line><span class=cl>      +0x008 Blink            : Ptr64 _LIST_ENTRY
</span></span><span class=line><span class=cl>         +0x000 Flink            : Ptr64 _LIST_ENTRY
</span></span><span class=line><span class=cl>         +0x008 Blink            : Ptr64 _LIST_ENTRY
</span></span><span class=line><span class=cl>   +0x018 ServiceRoutine   : Ptr64     unsigned char 
</span></span><span class=line><span class=cl>   +0x020 MessageServiceRoutine : Ptr64     unsigned char 
</span></span><span class=line><span class=cl>   +0x028 MessageIndex     : Uint4B
</span></span><span class=line><span class=cl>   +0x030 ServiceContext   : Ptr64 Void
</span></span><span class=line><span class=cl>   +0x038 SpinLock         : Uint8B
</span></span><span class=line><span class=cl>   ...
</span></span></code></pre></td></tr></table></div></div><p>Note the repeated occurrence of <code>Flink</code> (<code>struct _LIST_ENTRY *Flink</code>) and <code>Blink</code> (<code>struct _LIST_ENTRY *Blink</code>) fields. This makes sense as the kernel uses a circular doubly linked-list, called <code>ActiveProcessLink</code> for internal data structures. Each field is of the type <code>LIST_ENTRY</code> (<code>typedef struct _LIST_ENTRY LIST_ENTRY, *PLIST_ENTRY</code>). <code>Flink</code> points to the next node, while <code>Blink</code> points to the previous one.</p><p>All <code>nt!_EPROCESS</code> structures are similarly linked to form <code>ActiveProcessLink</code> with the <code>ListHead</code> stored in <code>nt!PsActiveProcessHead</code>. <code>!process</code> displays information from <code>nt!_EPROCESS</code> structure.</p><p>I noted that if recursion depth is increased to <code>-r 4</code>, it breaks the output -></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lkd&gt; dt nt!_KINTERRUPT -r 4
</span></span><span class=line><span class=cl>   +0x000 Type             : ??
</span></span><span class=line><span class=cl>   +0x002 Size             : ??
</span></span><span class=line><span class=cl>   +0x008 InterruptListEntry : _LIST_ENTRY
</span></span><span class=line><span class=cl>      +0x000 Flink            : ???? 
</span></span><span class=line><span class=cl>      +0x008 Blink            : ???? 
</span></span><span class=line><span class=cl>   +0x018 ServiceRoutine   : ???? 
</span></span><span class=line><span class=cl>   +0x020 MessageServiceRoutine : ???? 
</span></span><span class=line><span class=cl>   +0x028 MessageIndex     : ??
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   +0x0b0 IsrDpcStats      : _ISRDPCSTATS
</span></span><span class=line><span class=cl>      +0x000 IsrTime          : ??
</span></span><span class=line><span class=cl>      +0x008 IsrTimeStart     : ??
</span></span><span class=line><span class=cl>      +0x010 IsrCount         : ??
</span></span><span class=line><span class=cl>      +0x018 DpcTime          : ??
</span></span><span class=line><span class=cl>      +0x020 DpcTimeStart     : ??
</span></span><span class=line><span class=cl>      +0x028 DpcCount         : ??
</span></span><span class=line><span class=cl>      +0x030 IsrActive        : ??
</span></span><span class=line><span class=cl>      +0x031 Reserved         : [7]  &#34;--- memory read error at address 0x00000000`000000e5 ---&#34;
</span></span><span class=line><span class=cl>      +0x038 DpcWatchdog      : _ISRDPCSTATS_SEQUENCE
</span></span><span class=line><span class=cl>         +0x000 SequenceNumber   : ??
</span></span><span class=line><span class=cl>         +0x008 IsrTime          : ??
</span></span><span class=line><span class=cl>         +0x010 IsrCount         : ??
</span></span><span class=line><span class=cl>         +0x018 DpcTime          : ??
</span></span><span class=line><span class=cl>         +0x020 DpcCount         : ??
</span></span><span class=line><span class=cl>   +0x110 RedirectObject   : ???? 
</span></span><span class=line><span class=cl>   +0x118 Padding          : [8]  &#34;--- memory read error at address 0x00000000`0000011c ---&#34;
</span></span><span class=line><span class=cl>Memory read error 0000000000000114
</span></span></code></pre></td></tr></table></div></div><p>The (probable!) cause might be that the memory indicated by <code>??</code> is uncommitted or de-allocated. As a process&rsquo; memory remains virtual unless <code>VirtualAlloc</code> allocates memory and zero-initializes it.</p><blockquote><p>I encourage you to experiment with <code>lkd</code> to become familiar with the syntax. <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/getting-started-with-windbg--kernel-mode->Here</a> is the resource you might need.</p></blockquote><p>A process can be created using several WinAPI functions -></p><ol><li><p><code>CreateProcessA</code> -> Most basic function which attempts to create a process and its primary thread with the same access token as the creating process. If a different token is required, <code>CreateProcessAsUser</code> can be used.</p></li><li><p><code>CreateProcessWithTokenW</code> -> Part of the <code>advapi32.dll</code>, it is similar to <code>CreateProcessAsUser</code> the difference being the privileges required for the caller.</p></li><li><p><code>CreateProcessWithLogonW</code> -> A handy shortcut to log on with a given user&rsquo;s credentials (user, domain, and password).</p></li></ol><p>All of the above have different use cases but eventually, all execution paths lead to <code>CreateProcessInternal</code> which calls <code>NtCreateUserProcess</code> (part of) which makes the transition to kernel mode and continues the kernel mode part of the process creation with the same name. As the name suggests, <code>NtCreateUserProcess</code> creates a user process. A user cannot create a native process, such as <code>smss.exe</code> and <code>csrss.exe</code>, as <code>CreateProcessInternal</code> function will reject images with native subsystem image type.</p><p>Apart from NT Processes, the Kernel Executive supports additional processes, that are created bypassing WinAPI, such as Native processes, Minimal, or Pico Processes. These would be beyond the scope of this post.</p><blockquote><p>You might be following along in a VM. If you are using VMware, you might notice performance slowdowns or hangs, which can get quite frustrating. There is a good way to get more performance!</p><ul><li>If you&rsquo;re using VMWare Player, make sure the VM is &ldquo;Shut Down&rdquo; and not &ldquo;Suspended&rdquo;. Then, navigate to the Virtual Machine working directory. Locate the config file <code>.vmx</code>. Open that in an editor and add the following line to it -> <code>ulm.disableMitigations = "TRUE"</code>. This will disable side-channel mitigations applied to your VM.</li><li>If you&rsquo;re using Workstation pro, then you can directly disable side-channel mitigations in &ldquo;Edit Virtual Machine Settings&rdquo;.</li></ul></blockquote><h3 id=threads>Threads<a hidden class=anchor aria-hidden=true href=#threads>#</a></h3><p>A thread is a subcomponent of a process that does the actual execution. A process contains threads (at a minimum, 1 thread). Threads have their address space isolated from each other and share a common address space of the process. At OS-level, a Windows thread is represented by an executive thread object. This object encapsulates <code>nt!_ETHREAD</code> (which is also an opaque kernel structure) which contains, among others, <code>nt!_KTHREAD</code> structure as its first member. <code>nt!_KTHREAD</code> points to several other structures all of which reside in system address space, with the exception of <strong>Thread Environment Block</strong> (TEB). TEB, like PEB, resides in userspace.</p><p>The Windows subsystem process (csrss) maintains a parallel data structure <code>CSR_THREAD</code>. For threads that have called a Windows subsystem <code>USER</code> or <code>GDI</code> function, the kernel-mode portion of the Windows Subsystem (<code>Win32k.sys</code>) maintains a per-thread data structure (<code>W32THREAD</code>) that the <code>KTHREAD</code> structure points to.</p><p>The simplest function to create a thread is <code>CreateThread</code> function which creates a thread in the current process. On successful completion, a non-zero handle is returned, and a unique thread ID if requested by the caller.</p><p><code>CreateRemoteThread</code> is used to inject a thread into another process. It can be used by the debugger to force a break in a debugged process. The debugger injects the thread which immediately causes a breakpoint by calling the <code>DebugBreak</code> function. Another use can be to obtain information about a process when running within the target process context, this can be done for legitimate or malicious purposes.</p><p>Going back to <code>lkd</code>, you can use it to examine <code>nt!_ETHREAD</code> -></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lkd&gt; dt nt!_ETHREAD
</span></span><span class=line><span class=cl>   +0x000 Tcb              : _KTHREAD
</span></span><span class=line><span class=cl>   +0x480 CreateTime       : _LARGE_INTEGER
</span></span><span class=line><span class=cl>   +0x488 ExitTime         : _LARGE_INTEGER
</span></span><span class=line><span class=cl>   +0x488 KeyedWaitChain   : _LIST_ENTRY
</span></span><span class=line><span class=cl>   +0x498 PostBlockList    : _LIST_ENTRY
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   +0x560 DisableDynamicCodeOptOut : Pos 18, 1 Bit
</span></span><span class=line><span class=cl>   +0x560 ExplicitCaseSensitivity : Pos 19, 1 Bit
</span></span><span class=line><span class=cl>   +0x560 PicoNotifyExit   : Pos 20, 1 Bit
</span></span><span class=line><span class=cl>   +0x560 DbgWerUserReportActive : Pos 21, 1 Bit
</span></span><span class=line><span class=cl>   +0x560 ForcedSelfTrimActive : Pos 22, 1 Bit
</span></span><span class=line><span class=cl>   +0x560 SamplingCoverage : Pos 23, 1 Bit
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   +0x6b8 LastExpectedRunTime : Uint4B
</span></span><span class=line><span class=cl>   +0x6bc LastSoftParkElectionRunTime : Uint4B
</span></span><span class=line><span class=cl>   +0x6c0 LastSoftParkElectionGeneration : Uint8B
</span></span><span class=line><span class=cl>   +0x6c8 LastSoftParkElectionGroupAffinity : _GROUP_AFFINITY
</span></span><span class=line><span class=cl>   +0x6d8 UpdateTebListEntry : _SINGLE_LIST_ENTRY
</span></span></code></pre></td></tr></table></div></div><p>Listed above are the structures inside <code>nt!_ETHREAD</code> and their types. For instance, <code>Tcb</code> is of type <code>_KTHREAD</code>, and <code>CreateTime</code> is an instance of <code>_LARGE_INTEGER</code> structure.</p><p><code>!thread</code> can be used to view information about a thread. But this can only be used in kernel-mode debugging.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lkd&gt; !thread
</span></span><span class=line><span class=cl>   THREAD ffff830869dec080  Cid 24cc.0250  Teb: 0000003a3cb00000 Win32Thread: ffff83086dfe3da0 WAIT: (WrUserRequest) UserMode Non-Alertable
</span></span><span class=line><span class=cl>      ffff83086fb5f280  QueueObject
</span></span><span class=line><span class=cl>   IRP List:
</span></span><span class=line><span class=cl>      ffff83086eac8ba0: (0006,0358) Flags: 00060800  Mdl: 00000000
</span></span><span class=line><span class=cl>   Not impersonating
</span></span><span class=line><span class=cl>   DeviceMap                 ffffe586f8dcf270
</span></span><span class=line><span class=cl>   Owning Process            ffff83086fea80c0       Image:         DbgX.Shell.exe
</span></span><span class=line><span class=cl>   Attached Process          N/A            Image:         N/A
</span></span><span class=line><span class=cl>   Wait Start TickCount      5303564        Ticks: 748 (0:00:00:11.687)
</span></span><span class=line><span class=cl>   Context Switch Count      2299901        IdealProcessor: 1             
</span></span><span class=line><span class=cl>   UserTime                  00:05:51.000
</span></span><span class=line><span class=cl>   KernelTime                00:03:42.062
</span></span><span class=line><span class=cl>   Win32 Start Address 0x00007ff678783d50
</span></span><span class=line><span class=cl>   Stack Init ffff960b2293ac70 Current ffff960b2293a050
</span></span><span class=line><span class=cl>   Base ffff960b2293b000 Limit ffff960b22935000 Call 0000000000000000
</span></span><span class=line><span class=cl>   Priority 12 BasePriority 8 PriorityDecrement 2 IoPriority 2 PagePriority 5
</span></span><span class=line><span class=cl>   Unable to get context for thread running on processor 1, HRESULT 0x80004001
</span></span></code></pre></td></tr></table></div></div><ul><li><p>The 64-bit hexadecimal number after <code>THREAD</code> is the address of <code>ETHREAD</code> block.</p></li><li><p>Two 16-bit hexadecimal numbers after <code>Cid</code> are of the form <em>processID.threadID</em>, processID is 0x24cc and threadID is 0x0250 in this case.</p></li><li><p>The 64-bit hexadecimal number after <code>Teb</code> is the address of <strong>Thread Environment Block</strong> (TEB).</p></li><li><p>The 64-bit hexadecimal number after <code>Win32Thread</code> is the address of Win32Thread.</p></li></ul><p>Apart from these, other fields show stack trace, priority, thread start address, owning process, and thread state.</p><h3 id=virtual-memory>Virtual Memory<a hidden class=anchor aria-hidden=true href=#virtual-memory>#</a></h3><p>It is what is written on the box, a memory that doesn&rsquo;t exists (but is mapped). When a processor writes to a memory location it writes to a virtual address. The essence of virtual memory lies in the fact that from an execution perspective, the CPU doesn&rsquo;t need to know whether the memory is mapped to RAM or Disk.</p><p>Below is the layout for two &ldquo;extreme&rdquo; cases: a 32-bit process on a 32-bit system (left) and a 64-bit process on a 64-bit system (right) -></p><figure class=align-center><img loading=lazy src=/images/VMLayout.png#center alt="Object categorization in Windows"><figcaption><p>Virtual Memory Layout in Different Cases, Source: Windows Kernel Programming, 2nd Edition.</p></figcaption></figure><p>If the requested page doesn&rsquo;t exist in RAM, the CPU raises a page fault exception, which causes the memory manager&rsquo;s page fault exception handler to fetch data from the file (if it&rsquo;s a valid page fault), copy it to RAM, update the page table entries and instruct CPU to try again.</p><p>Windows also supports large pages, by using <strong>Page Directory Entry</strong> (PDE) to directly map a large page without using a page table. This makes better use of <strong>Translation Lookaside Buffer</strong> (TLB) - a cache of recently translated pages maintained by the CPU.</p><blockquote><p>A non-paged area is a memory region that is guaranteed to remain in memory as it&rsquo;s never paged. But the Windows Bug Check error <code>PAGE_FAULT_IN_NONPAGED_AREA</code> (<code>0x00000050</code>) seemingly contradicts this idea that a page fault cannot happen in a region where the referenced memory is guaranteed to be in RAM. Interesting!
A probable cause for this might be a situation where a driver misuses non-paged pool allocations and/or references invalid memory. Bad driver code or corrupt system memory is the major reason almost all the time.</p></blockquote><h3 id=mode-of-execution>Mode of Execution<a hidden class=anchor aria-hidden=true href=#mode-of-execution>#</a></h3><p>This refers to the nature of the code being executed. Does that belong to a user application or a part of a kernel component? The nature of code determines the privilege assigned to it. To support this structure, x64 processors are divided into privilege levels/rings -> Ring 3 to Ring 0. The purpose is to differentiate system and user data, and to protect it from inadvertent/malicious access or writes.</p><blockquote><p>These rings go even deeper in modern Intel/AMD Processors -></p><ul><li>Ring -1: Hypervisor</li><li>Ring -2: System Management Mode (SMM)</li><li>Ring -3: Intel Management Engine (ME). With a special emphasis, this sub-component is downright dystopian. To understand why, I highly encourage you go to through the post -> <a href=https://medium.com/swlh/negative-rings-in-intel-architecture-the-security-threats-youve-probably-never-heard-of-d725a4b6f831>Negative Rings in Intel Architecture: The Security Threats That You’ve Probably Never Heard Of</a> on Medium by <a href=https://medium.com/@RealWorldCyberSecurity>RealWorldCyberSecurity</a>.</li></ul><p>Below these exist the Microcode (which is a layer between CPU hardware and programmer visible ISA) and the actual Silicon.</p></blockquote><p>When a user launches an application, Windows creates a private virtual address space and a private handle table (more on this later). Each page in Virtual Memory is tagged to indicate what access mode the processor must be in to read/or write the page. A user-mode application has its own private address space isolated from other processes and the OS. So, if a process crashes, it doesn&rsquo;t affect other processes, they keep running.</p><p>A kernel mode component, such as a Kernel-Mode driver, shares its address space with the whole kernel. This implies if a component crashes it takes the whole system with it. The kernel, <strong>Hardware Abstraction Layer</strong> (HAL), and kernel drivers operate in kernel space.</p><h3 id=system-services>System Services<a hidden class=anchor aria-hidden=true href=#system-services>#</a></h3><p>Or System Calls are used to request kernel services like reading from the file, thread creation, etc. System calls in Windows follow a rather complex path as compared to Unix syscalls. Under Windows, user applications don&rsquo;t call the native Windows OS services directly. Rather, they go through one or more subsystem Dynamic-Link Libraries (DLLs).</p><p>Take file creation for example.</p><p>When a user creates a new file in <em>Notepad</em>, its code calls <code>CreateFile</code>, which is documented, and implemented in <code>kernel32.dll</code>. This function runs in user mode, so there is no way it can open a file. After some error checking, it calls <code>NtCreateFile</code>, a function implemented in <code>ntdll.dll</code>. It is documented and is the one that makes the actual transition to kernel mode. Before the transition, it puts a number called <strong>System Service Number</strong>, into a CPU register (<code>EAX</code> on Intel/AMD architectures). Then it issues a special CPU instruction (<code>syscallon</code> on x64 or <code>sysenter</code> on x86) that makes the actual transition to kernel mode while jumping to a predefined routine called the <strong>System Service Dispatcher</strong> (SSD). The SSD, in turn, uses the value in the <code>EAX</code> register as an index into a <strong>System Service Dispatch Table</strong> (SSDT). Using this table, the code jumps to the system service (call) itself. For the <em>Notepad</em> example, the SSDT entry would point to <code>NtCreateFile</code>, implemented by the kernel I/O manager.</p><p>This can be seen in action. Open <em>Notepad.exe</em> in &lsquo;WinDbg Preview&rsquo;. Upon attaching to the process, the debugger will hit a default breakpoint -></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(6b4.840): Break instruction exception - code 80000003 (first chance)
</span></span><span class=line><span class=cl>ntdll!LdrpDoDebuggerBreak+0x30:
</span></span><span class=line><span class=cl>00007ff8`fac8c0e0 cc              int     3
</span></span></code></pre></td></tr></table></div></div><p>Set a breakpoint in <code>NtCreateFile</code> inside <code>ntdll.dll</code> using <code>bp ntdll!ntcreatefile</code>. Then type <code>g</code> (go) to continue execution. The newly set breakpoint will hit almost immediately.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   Breakpoint 0 hit
</span></span><span class=line><span class=cl>   ntdll!NtCreateFile:
</span></span><span class=line><span class=cl>   00007ff8`fac50320 4c8bd1          mov     r10,rcx
</span></span></code></pre></td></tr></table></div></div><p>Enter <code>u</code> (unassembled) command to see a few instructions ahead -></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0:000&gt; u
</span></span><span class=line><span class=cl>   ntdll!NtCreateFile:
</span></span><span class=line><span class=cl>   00007ff8`fac50320 4c8bd1          mov     r10,rcx
</span></span><span class=line><span class=cl>   00007ff8`fac50323 b855000000      mov     eax,55h
</span></span><span class=line><span class=cl>   00007ff8`fac50328 f604250803fe7f01 test    byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],1
</span></span><span class=line><span class=cl>   00007ff8`fac50330 7503            jne     ntdll!NtCreateFile+0x15 (00007ff8`fac50335)
</span></span><span class=line><span class=cl>   00007ff8`fac50332 0f05            syscall
</span></span><span class=line><span class=cl>   00007ff8`fac50334 c3              ret
</span></span><span class=line><span class=cl>   00007ff8`fac50335 cd2e            int     2Eh
</span></span><span class=line><span class=cl>   00007ff8`fac50337 c3              ret
</span></span></code></pre></td></tr></table></div></div><p>As mentioned above, <code>EAX</code> is set with SSN -> 0x55. This is the system call number. Then notice the <code>syscall</code> instruction. This switches the processor to kernel mode, jumping to the SSDT entry corresponding to the value inside <code>EAX</code>. Predictably, 0x55 corresponds to <code>NtCreateFile</code>. Notice the flag value set to 1 at offset 0x308 to <code>SharedUserData</code>. If this flag is set, the execution will take another path using the <code>int 2Eh</code> instruction on the second to last line of the output above. This flag corresponds to a specific Credential Guard VBS (Virtualization Based Security) feature as the hypervisor can better react to <code>int</code> instruction rather than <code>syscall</code>.</p><p>All right! Enough for this one!</p><h3 id=objects-and-handles>Objects and Handles<a hidden class=anchor aria-hidden=true href=#objects-and-handles>#</a></h3><p>In Windows, an object is a single, runtime instance of a statically defined object. They are kernel data structures representing commonly used facilities like files, registry keys, processes, threads, devices, etc. that are managed by the Object Manager, a component of the Windows Kernel. Not all objects have names, for eg., processes and threads don&rsquo;t have names - they have IDs. That’s why the <code>OpenProcess()</code> and <code>OpenThread()</code> functions require a process/thread identifier (a number) rather than a string-base name.</p><p>Windows has three primary types of objects: Executive Objects, Kernel Objects, and GDI/User Objects.</p><figure class=align-center><img loading=lazy src=/images/ObjectCat.png#center alt="Object categorization in Windows"><figcaption><p>Object categorization, Source: Windows Internals, Part 1.</p></figcaption></figure><ul><li>Executive objects are implemented by various components of the executive (such as process manager, memory manager, and I/O subsystem).</li><li>Kernel objects are a more primitive set of objects implemented by the Windows kernel. These objects are not visible to user-mode code but are created and used only within the executive.</li><li>Majority of GDI/User objects belong to the Windows subsystem (Win32k.sys) and do not interact with the kernel.</li></ul><p>WinObj tool from Sysinternals displays all objects in the system.</p><figure class=align-center><img loading=lazy src=/images/WinObj.png#center alt="A screenshot showing all objects in Object manager"><figcaption><p>All GLOBAL$$ objects as viewed in WinObj.</p></figcaption></figure><p>All such objects are preceded by an <code>nt!_OBJECT_HEADER</code> structure that contains information about the object and is used to manage the life cycle of the object, allow it to be uniquely named, and secure it by applying access control, invoke the object type-specific methods and track the allocator&rsquo;s quota usage.</p><p>Handles are references returned to the caller by the callee (APIs in this case) that are then translated to pointers by WDF. Processes in Windows have their own handle table which is stored in the kernel virtual address space. Handles are always a multiple of 4, and 0 is never a valid handle value.</p><p>The kernel (and driver) code can either work with a handle or pointer to an object. Handles can be converted to points using <code>ObDereferenceObjectByHandle()</code> and <code>ObReferenceObjectByHandle()</code> functions. The former function returns a pointer to the object and the latter function increments the reference count of the object. The reference count is decremented when the object is no longer needed. The object is freed when the reference count reaches 0. Object manager destroys the object if its reference count reaches 0.</p><p><code>nt!_HANDLE_TABLE_ENTRY</code> represents an individual entry in the process handle table. Handle tables are allocated from Paged Pool. When a process terminates the function <code>ExSweepHandleTable()</code> closes all handles in the handle table of that process.</p><p><code>!handle</code> can be used to examine the handle table of the currently running process. The output would be huge!</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lkd&gt; !handle
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>PROCESS ffff9f016a6e4080
</span></span><span class=line><span class=cl>    SessionId: 1  Cid: 067c    Peb: 293d469000  ParentCid: 09bc
</span></span><span class=line><span class=cl>    DirBase: 5bb72002  ObjectTable: ffffcd04ce0bdd00  HandleCount: 754.
</span></span><span class=line><span class=cl>    Image: DbgX.Shell.exe
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Handle table at ffffcd04ce0bdd00 with 758 entries in use
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0004: Object: ffff9f016aef20e0  GrantedAccess: 001f0003 (Protected) (Inherit) Entry: ffffcd04cd8f7010
</span></span><span class=line><span class=cl>Object: ffff9f016aef20e0  Type: (ffff9f01638b30c0) Event
</span></span><span class=line><span class=cl>    ObjectHeader: ffff9f016aef20b0 (new version)
</span></span><span class=line><span class=cl>        HandleCount: 1  PointerCount: 32768
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0008: Object: ffff9f016aef1be0  GrantedAccess: 001f0003 (Protected) (Inherit) Entry: ffffcd04cd8f7020
</span></span><span class=line><span class=cl>Object: ffff9f016aef1be0  Type: (ffff9f01638b30c0) Event
</span></span><span class=line><span class=cl>    ObjectHeader: ffff9f016aef1bb0 (new version)
</span></span><span class=line><span class=cl>        HandleCount: 1  PointerCount: 32755
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>000c: Object: ffff9f016abbeee0  GrantedAccess: 00000001 (Protected) (Inherit) Entry: ffffcd04cd8f7030
</span></span><span class=line><span class=cl>Object: ffff9f016abbeee0  Type: (ffff9f01638c2380) WaitCompletionPacket
</span></span><span class=line><span class=cl>    ObjectHeader: ffff9f016abbeeb0 (new version)
</span></span><span class=line><span class=cl>        HandleCount: 1  PointerCount: 32755
</span></span></code></pre></td></tr></table></div></div><p>The output displays the handle table of the current process and properties of individual handles, including a total of 758 entries. The <code>HandleCount</code> field shows 754 entries, but the OS allocates additional handles for improved performance, resulting in 758 entries in the table.</p><h3 id=subsystems-subsystem-dlls-and-ntdlldll>Subsystems, Subsystem DLLs and ntdll.dll<a hidden class=anchor aria-hidden=true href=#subsystems-subsystem-dlls-and-ntdlldll>#</a></h3><p>A subsystem is a facility by which Windows exposes some subset of the base Windows executive system services to application programs.</p><p>This means that some things that can be done from an application built on one subsystem can&rsquo;t be done by another application built on another subsystem. Each executable image <code>.exe</code> is bound to only one subsystem. Subsystems are started by the Session Manager (Smss.exe) process. Subsystem startup information is stored under the registry key <code>HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems</code></p><p>During process creation, the process creation code examines the sub-system type header code and notifies the target subsystem of the new process. This type of code is defined in the <code>/SUBSYSTEM</code> linker flag of Visual Studio Linker.</p><p>You can view the image subsystem type using the Dependency Walker (depends.exe). If you check <em>notepad.exe</em> -></p><figure class=align-center><img loading=lazy src=/images/dependsNotepad.png#center alt="An output window showing dependencies of Notepad.exe"><figcaption><p>Dependency Listing of Notepad.exe in depends.exe.</p></figcaption></figure><p>The role of subsystem DLLs is to translate a documented function into the appropriate internal (and generally undocumented) native system service calls implemented mostly in <code>NTDLL.DLL</code>.</p><p><code>NTDLL.DLL</code> comprises the lowest layer of code that still runs in user mode. It acts as a special support library primarily for the use of subsystem DLLs and native applications. Native images are those images that are not tied to any particular subsystem.</p><h3 id=hardware-abstraction-layer-hal>Hardware Abstraction Layer (HAL)<a hidden class=anchor aria-hidden=true href=#hardware-abstraction-layer-hal>#</a></h3><p>The HAL is a loadable kernel-mode module (Hal.dll) that provides the low-level interface to the hardware platform on which Windows is running. This is a layer of code that isolates the kernel, the device drivers, and the rest of the Windows Executive from platform-specific hardware differences.</p><p>It hides hardware-dependent details such as I/O interfaces, interrupt controllers, and multiprocessor communication mechanisms — any functions that are both architecture-specific and machine-dependent. So rather than access hardware directly, Windows internal components and user-written device
drivers maintain portability by calling the HAL routines when they need platform-dependent information. For this reason, many HAL routines are documented in the WDK.</p><h3 id=hyper-v-hypervisor-and-driver-code-security-challenges>Hyper-V Hypervisor and Driver Code Security Challenges<a hidden class=anchor aria-hidden=true href=#hyper-v-hypervisor-and-driver-code-security-challenges>#</a></h3><p>This contains the hypervisor. There are no drivers or other modules in this environment. That being said, the hypervisor itself is composed of multiple internal layers and services, such as its own Memory Manager, Virtual Processor scheduler, Interrupt and Time management, Synchronization Routines, Partitions (VM instances) management, and Inter-Partition Communication (IPC), and more. This is one level below Ring 0 privilege, Ring -1.</p><p>One of the main roles of Hyper-V in Windows 10 and Windows Server 2016 (and later) is to enable support for Virtualization Based Security (VBS).</p><p>VBS provides an extra layer of security as the normal OS exists as a Hyper-V VM. Windows uses Virtual Trust Levels (VTLs), which use the hypervisor to configure virtual trust levels. This is to address challenges arising from malicious driver code which could access kernel-mode memory.</p><p>VBS provides extra security on top of processor isolation.</p><h3 id=conclusion-and-credits>Conclusion and Credits<a hidden class=anchor aria-hidden=true href=#conclusion-and-credits>#</a></h3><p>In this post, you learned about Windows Processes, Threads, System Services, and other specific topics like Virtual Memory, Objects, and Handles.</p><p>In the next post, you&rsquo;ll start building your first driver. All the subsequent posts will lay more emphasis on the driver development process and would be code intensive.</p><p>Stay Tuned!</p><p>Tx0actical. Out.</p><blockquote><p>This post draws inspiration from <a href=https://www.microsoftpressstore.com/store/windows-internals-part-1-system-architecture-processes-9780735684188>Windows Internals</a>, if you wish to dive even deeper (The book, for instance, explains Session Manager, <code>smss.exe</code> in 38 points!), <a href=https://leanpub.com/windowskernelprogrammingsecondedition>Windows Kernel Programming</a>, the official <a href=https://learn.microsoft.com/en-us/windows/>Microsoft documentation</a> and <strong>my experimentation</strong>. Also, if you wish to dive deeper into Windows Internals for security research, I would highly recommend <a href=https://codemachine.com/index.html>CodeMachine</a>, they provide training for all things &ldquo;Windows Security&rdquo;. Some of their articles have also inspired this post.</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://Tx0actical.github.io/tags/drivers/>Drivers</a></li><li><a href=https://Tx0actical.github.io/tags/windows/>Windows</a></li></ul><nav class=paginav><a class=prev href=https://Tx0actical.github.io/posts/hackasat4-gg/><span class=title>« Prev</span><br><span>GGs - Farewell to ADCS</span></a>
<a class=next href=https://Tx0actical.github.io/posts/win-drivers/win-drivers-p1/><span class=title>Next »</span><br><span>0x01 Introduction and Fundamentals</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 0x02 Advanced Windows Internals on twitter" href="https://twitter.com/intent/tweet/?text=0x02%20Advanced%20Windows%20Internals&amp;url=https%3a%2f%2fTx0actical.github.io%2fposts%2fwin-drivers%2fwin-drivers-p2%2f&amp;hashtags=Drivers%2cWindows"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 0x02 Advanced Windows Internals on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fTx0actical.github.io%2fposts%2fwin-drivers%2fwin-drivers-p2%2f&amp;title=0x02%20Advanced%20Windows%20Internals&amp;summary=0x02%20Advanced%20Windows%20Internals&amp;source=https%3a%2f%2fTx0actical.github.io%2fposts%2fwin-drivers%2fwin-drivers-p2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://Tx0actical.github.io/>Tx0actical's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>