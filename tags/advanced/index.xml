<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Advanced on Tx0actical&#39;s Blog</title>
    <link>https://Tx0actical.github.io/tags/advanced/</link>
    <description>Recent content in Advanced on Tx0actical&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2023 Tx0actical</copyright>
    <lastBuildDate>Mon, 27 Feb 2023 15:54:12 +0530</lastBuildDate><atom:link href="https://Tx0actical.github.io/tags/advanced/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>0x02 Advanced Windows Internals</title>
      <link>https://Tx0actical.github.io/posts/win-drivers/win-drivers-p2/</link>
      <pubDate>Mon, 27 Feb 2023 15:54:12 +0530</pubDate>
      
      <guid>https://Tx0actical.github.io/posts/win-drivers/win-drivers-p2/</guid>
      <description>Hello.
KMDF (or WDF for that matter) being a Windows thing, you need to understand some Windows fundamentals.
In this iteration, Part 2, of &amp;ldquo;Writing Windows KMDF Drivers for Fun and Profit&amp;rdquo;, I&amp;rsquo;ll introduce you to important Windows Concepts such as Processes, Threads, Virtual Memory, System Services, Objects and Handles, Subsystems, and the Hyper-V Hypervisor. You&amp;rsquo;ll discover these constructs in great detail in this post. This post is informational and explorational in nature and can be treated as a reference, if you will.</description>
      <content>&lt;p&gt;Hello.&lt;/p&gt;
&lt;p&gt;KMDF (or WDF for that matter) being a Windows thing, you need to understand some Windows fundamentals.&lt;/p&gt;
&lt;p&gt;In this iteration, Part 2, of &amp;ldquo;Writing Windows KMDF Drivers for Fun and Profit&amp;rdquo;, I&amp;rsquo;ll introduce you to important Windows Concepts such as Processes, Threads, Virtual Memory, System Services, Objects and Handles, Subsystems, and the Hyper-V Hypervisor. You&amp;rsquo;ll discover these constructs in great detail in this post. This post is informational and explorational in nature and can be treated as a reference, if you will. With this I wanted to focus on experimentation and a deep-dive explanation, and do something different instead of replaying information that already exists.&lt;/p&gt;
&lt;p&gt;Anyone who&amp;rsquo;s ever dug a little deep about Windows, might be familiar with this image:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tx0actical.github.io/images/WinArch.png&#34; alt=&#34;WinArch&#34;&gt;
*Source: Windows Internals: Part 1 *&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;ll now try to explain this.&lt;/p&gt;
&lt;h3 id=&#34;processes&#34;&gt;Processes&lt;/h3&gt;
&lt;p&gt;A process is a management and containment object which represents an instance of a program. Contrary to popular belief, processes don&amp;rsquo;t run, they &amp;ldquo;manage&amp;rdquo;. Each Windows process is defined by an executive process structure or &lt;code&gt;nt!_EPROCESS&lt;/code&gt;. This structure (&lt;code&gt;typedef struct _EPROCESS EPROCESS, *PEPROCESS&lt;/code&gt; to be exact) is the kernel&amp;rsquo;s representation of a process object. It exists only in kernel memory, user-mode can access indirectly through handles (handles are explained later). The Windows kernel maintains a &lt;code&gt;nt!_EPROCESS&lt;/code&gt; structure for every process including -&amp;gt; System Idle Process (PID 0) and System (Process) (PID 4).&lt;/p&gt;
&lt;p&gt;It is an &lt;a href=&#34;https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/eprocess&#34;&gt;opaque kernel structure&lt;/a&gt; defined as -&amp;gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_EPROCESS&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ... &lt;span style=&#34;color:#75715e&#34;&gt;// Opaque
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} EPROCESS, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;PEPROCESS;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;nt!_EPROCESS&lt;/code&gt; and its constituent data structures are contained in the System address space, with the exception of &lt;strong&gt;Process Control Block&lt;/strong&gt; (PCB) which exists in User space.&lt;/p&gt;
&lt;p&gt;Moreover, the subsystem service &lt;code&gt;csrss.exe&lt;/code&gt; maintains a parallel data structure &lt;code&gt;CSR_PROCESS&lt;/code&gt;. Additionally, the kernel mode part of the subsystem &lt;code&gt;Win32k.sys&lt;/code&gt; maintains a per-process data structure, &lt;code&gt;W32PROCESS&lt;/code&gt;. Except for the &lt;code&gt;idle&lt;/code&gt; process every process has a process object associated with it.&lt;/p&gt;
&lt;p&gt;To see all processes, use &lt;code&gt;!process 0 0&lt;/code&gt; in the Kernel Debugger.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;This post introduces the Kernel Debugger. It is a useful tool to examine internal components. To get started, you&amp;rsquo;ll need to -&amp;gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Enable debugging. To do that, in an elevated command prompt, type &lt;code&gt;bcdedit /debug on&lt;/code&gt; and restart.&lt;/li&gt;
&lt;li&gt;If secure boot is enabled, might need to do additional changes in boot menu (You can avoid the hassle of tinkering with BIOS options. Instead, use a VM. Follow above-mentioned steps, and you&amp;rsquo;ll be good to go).&lt;/li&gt;
&lt;li&gt;Install &amp;ldquo;WinDbg Preview&amp;rdquo; from Microsoft Store.&lt;/li&gt;
&lt;li&gt;After it&amp;rsquo;s installed, go to &amp;lsquo;Home&amp;rsquo; -&amp;gt;
&amp;lsquo;Attach to kernel&amp;rsquo; -&amp;gt; &lt;em&gt;Select&lt;/em&gt; &amp;lsquo;Local&amp;rsquo;. This will start a Local Kernel Debugging Session.&lt;/li&gt;
&lt;li&gt;Once there, you can type all the commands in &lt;code&gt;lkd&lt;/code&gt; in command window.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Many other drivers and system components, by registering process-creation notification, can choose to create their own data structure to store information on a per-process basis. The executive functions &lt;code&gt;PsSetCreateProcessNotifyRoutineEx&lt;/code&gt; and &lt;code&gt;PsSetCreateProcessNotifyRoutineEx2&lt;/code&gt; allow this and are documented in WDK. This technique might find its use in AV, EDR/XDR implementations.&lt;/p&gt;
&lt;p&gt;You can see the contents of &lt;code&gt;nt!_EPROCESS&lt;/code&gt; structure in &lt;code&gt;lkd&lt;/code&gt; (Kernel Debugger). &lt;code&gt;dt nt!_EPROCESS&lt;/code&gt; lists all fields of &lt;code&gt;nt!_EPROCESS&lt;/code&gt; structure and their offsets in hexadecimal. Here&amp;rsquo;s what it looks like -&amp;gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;lkd&amp;gt; dt nt!_EPROCESS
   +0x000 Pcb              : _KPROCESS
   +0x438 ProcessLock      : _EX_PUSH_LOCK
   +0x440 UniqueProcessId  : Ptr64 Void
   ...
   +0x520 SectionBaseAddress : Ptr64 Void
   +0x528 Cookie           : Uint4B
   +0x530 WorkingSetWatch  : Ptr64 _PAGEFAULT_HISTORY
   ...
   +0xb8c MinimalTerminate : Pos 1, 1 Bit
   +0xb90 SyscallUsage     : Uint4B
   +0xb90 SyscallUsageValues : &amp;lt;unnamed-tag&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Usually, you&amp;rsquo;ll find &lt;code&gt;EPROCESS&lt;/code&gt; not &lt;code&gt;nt!_EPROCESS&lt;/code&gt; that&amp;rsquo;s because in the kernel debugger, latter is the symbol for the former, that is used for identification of structures during debugging.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;dt&lt;/code&gt; (display type) also shows specific contents of one or multiple fields by typing their names following structure name. Like so -&amp;gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;lkd&amp;gt; dt nt!_EPROCESS ProcessLock
   +0x438 ProcessLock : _EX_PUSH_LOCK
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the output above, the command examines &lt;code&gt;ProcessLock&lt;/code&gt; (&lt;code&gt;_EX_PUSH_LOCK&lt;/code&gt;) field.&lt;/p&gt;
&lt;p&gt;To see a list of kernel structures use &lt;code&gt;dt nt!_*&lt;/code&gt;. Note that &lt;code&gt;ntkrnlmp&lt;/code&gt; is the internal name of 64-bit kernel.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;lkd&amp;gt; dt nt!_*
   ntkrnlmp!_LIST_ENTRY
   ntkrnlmp!_LIST_ENTRY
   ntkrnlmp!_SINGLE_LIST_ENTRY
   ntkrnlmp!_UNICODE_STRING
   ntkrnlmp!_STRING
   ntkrnlmp!_RTL_QUERY_REGISTRY_TABLE
   ntkrnlmp!_LARGE_INTEGER
   ntkrnlmp!_ULARGE_INTEGER
   ntkrnlmp!_RTL_BITMAP
   ntkrnlmp!_KFLOATING_SAVE
   ntkrnlmp!_EXT_SET_PARAMETERS_V0
   ntkrnlmp!_POOL_TYPE
   ntkrnlmp!_EX_POOL_PRIORITY
   ntkrnlmp!_FAST_MUTEX
   ntkrnlmp!_EVENT_TYPE
   ...
   ntkrnlmp!_KINTERRUPT
   ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One of the structures is &lt;code&gt;ntkrnlmp!_KINTERRUPT&lt;/code&gt;. This &lt;code&gt;struct&lt;/code&gt; contains pointers to all &lt;strong&gt;Interrupt Service Routines&lt;/strong&gt; (ISR) registered by the kernel. ISRs execute on CPU whenever an Interrupt or Exception occurs. All ISRs are pointed to by something called an &lt;strong&gt;Interrupt Descriptor Table&lt;/strong&gt; or IDT, which is a CPU defined data structure. ISRs basically tell the CPU what code to execute when it encounters an interrupt.&lt;/p&gt;
&lt;p&gt;You can view the contents of the IDT, including information on what trap handlers Windows has assigned to interrupts (including exceptions and IRQs), using the &lt;code&gt;!idt&lt;/code&gt; command in &lt;code&gt;lkd&lt;/code&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;lkd&amp;gt; !idt

   Dumping IDT: fffff80219b1d000

   00:	fffff80216939100 nt!KiDivideErrorFaultShadow
   01:	fffff80216939180 nt!KiDebugTrapOrFaultShadow	Stack = 0xFFFFF80219B219D0
   02:	fffff80216939240 nt!KiNmiInterruptShadow	Stack = 0xFFFFF80219B217D0
   ...
   07:	fffff802169394c0 nt!KiNpxNotAvailableFaultShadow
   08:	fffff80216939540 nt!KiDoubleFaultAbortShadow	Stack = 0xFFFFF80219B213D0
   09:	fffff802169395c0 nt!KiNpxSegmentOverrunAbortShadow
   0a:	fffff80216939640 nt!KiInvalidTssFaultShadow
   0b:	fffff802169396c0 nt!KiSegmentNotPresentFaultShadow
   ...
   12:	fffff802169399c0 nt!KiMcheckAbortShadow	Stack = 0xFFFFF80219B215D0
   13:	fffff80216939ac0 nt!KiXmmExceptionShadow
   14:	fffff80216939b40 nt!KiVirtualizationExceptionShadow
   ...
   35:	fffff8021693a468 nt!HalpInterruptCmciService (KINTERRUPT fffff80216d38e60)
   36:	fffff8021693a470 nt!HalpInterruptCmciService (KINTERRUPT fffff80216d390a0)
   50:	fffff8021693a540 0xfffff80218609390 (KINTERRUPT ffffb081801e0a00)
   ...
   61:	fffff8021693a5c8 0xfffff80218355b20 (KINTERRUPT ffffb081807fec80)
   62:	fffff8021693a5d0 0xfffff802191df2a0 (KINTERRUPT ffffb081807fe640)
   ...
   e3:	fffff8021693a9d8 nt!HalpInterruptDeferredRecoveryService (KINTERRUPT fffff80216d38f80)
   fd:	fffff8021693aaa8 nt!HalpTimerProfileInterrupt (KINTERRUPT fffff80216d399a0)
   fe:	fffff8021693aab0 nt!HalpPerfInterrupt (KINTERRUPT fffff80216d39640)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Traps are a superset of Interrupts and Exceptions, a trap frame stores thread context and is a subset of thread&amp;rsquo;s complete execution context. The kernel also treats system services as exceptions (although they are also technically system traps).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The IDT has 256 entries, each one of which points to an ISR. The interrupt vector is the index of a particular slot in the IDT. The &lt;code&gt;nt!_KINTERRUPT&lt;/code&gt; structure represents a driver&amp;rsquo;s registration of an ISR for one of these vectors.&lt;/p&gt;
&lt;p&gt;Use the &lt;code&gt;-r&lt;/code&gt; flag to recursively examine all structures within &lt;code&gt;nt!_KINTERRUPT&lt;/code&gt;, a number after &lt;code&gt;-r&lt;/code&gt; determines the depth of recursion.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;lkd&amp;gt; dt nt!_KINTERRUPT -r
   +0x000 Type             : Int2B
   +0x002 Size             : Int2B
   +0x008 InterruptListEntry : _LIST_ENTRY
      +0x000 Flink            : Ptr64 _LIST_ENTRY
         +0x000 Flink            : Ptr64 _LIST_ENTRY
         +0x008 Blink            : Ptr64 _LIST_ENTRY
      +0x008 Blink            : Ptr64 _LIST_ENTRY
         +0x000 Flink            : Ptr64 _LIST_ENTRY
         +0x008 Blink            : Ptr64 _LIST_ENTRY
   +0x018 ServiceRoutine   : Ptr64     unsigned char 
   +0x020 MessageServiceRoutine : Ptr64     unsigned char 
   +0x028 MessageIndex     : Uint4B
   +0x030 ServiceContext   : Ptr64 Void
   +0x038 SpinLock         : Uint8B
   ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note the repeated occurance of &lt;code&gt;Flink&lt;/code&gt; (&lt;code&gt;struct _LIST_ENTRY *Flink&lt;/code&gt;) and &lt;code&gt;Blink&lt;/code&gt; (&lt;code&gt;struct _LIST_ENTRY *Blink&lt;/code&gt;) fields. This makes sense as kernel uses circular doubly linked-list, called &lt;code&gt;ActiveProcessLink&lt;/code&gt; for internal data structures. Each field is of the type &lt;code&gt;LIST_ENTRY&lt;/code&gt; (&lt;code&gt;typedef struct _LIST_ENTRY LIST_ENTRY, *PLIST_ENTRY&lt;/code&gt;). &lt;code&gt;Flink&lt;/code&gt; points to the next node, while &lt;code&gt;Blink&lt;/code&gt; points to the previous one.&lt;/p&gt;
&lt;p&gt;All &lt;code&gt;nt!_EPROCESS&lt;/code&gt; structures are similarly linked to form &lt;code&gt;ActiveProcessLink&lt;/code&gt; with the &lt;code&gt;ListHead&lt;/code&gt; stored in &lt;code&gt;nt!PsActiveProcessHead&lt;/code&gt;. &lt;code&gt;!process&lt;/code&gt; displays information from &lt;code&gt;nt!_EPROCESS&lt;/code&gt; structure.&lt;/p&gt;
&lt;p&gt;I noted that if recursion depth is increased to &lt;code&gt;-r 4&lt;/code&gt;, it apparently breaks the output -&amp;gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;lkd&amp;gt; dt nt!_KINTERRUPT -r 4
   +0x000 Type             : ??
   +0x002 Size             : ??
   +0x008 InterruptListEntry : _LIST_ENTRY
      +0x000 Flink            : ???? 
      +0x008 Blink            : ???? 
   +0x018 ServiceRoutine   : ???? 
   +0x020 MessageServiceRoutine : ???? 
   +0x028 MessageIndex     : ??
   ...
   +0x0b0 IsrDpcStats      : _ISRDPCSTATS
      +0x000 IsrTime          : ??
      +0x008 IsrTimeStart     : ??
      +0x010 IsrCount         : ??
      +0x018 DpcTime          : ??
      +0x020 DpcTimeStart     : ??
      +0x028 DpcCount         : ??
      +0x030 IsrActive        : ??
      +0x031 Reserved         : [7]  &amp;#34;--- memory read error at address 0x00000000`000000e5 ---&amp;#34;
      +0x038 DpcWatchdog      : _ISRDPCSTATS_SEQUENCE
         +0x000 SequenceNumber   : ??
         +0x008 IsrTime          : ??
         +0x010 IsrCount         : ??
         +0x018 DpcTime          : ??
         +0x020 DpcCount         : ??
   +0x110 RedirectObject   : ???? 
   +0x118 Padding          : [8]  &amp;#34;--- memory read error at address 0x00000000`0000011c ---&amp;#34;
Memory read error 0000000000000114
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The (probable!) cause might be that the memory indicated by &lt;code&gt;??&lt;/code&gt; is uncommitted or de-allocated. As a process&amp;rsquo; memory remains virtual unless &lt;code&gt;VirtualAlloc&lt;/code&gt; allocates memory and zero-initializes it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I encourage you to experiment with &lt;code&gt;lkd&lt;/code&gt; to become familiar with the syntax. &lt;a href=&#34;https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/getting-started-with-windbg--kernel-mode-&#34;&gt;Here&lt;/a&gt; is the resource you might need.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A process can be created using several WinAPI functions -&amp;gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CreateProcessA&lt;/code&gt; -&amp;gt; Most basic function which attempts to create a process and its primary thread with same access token as the creating process. If a different token is required, &lt;code&gt;CreateProcessAsUser&lt;/code&gt; can be used.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CreateProcessWithTokenW&lt;/code&gt; -&amp;gt; Part of the &lt;code&gt;advapi32.dll&lt;/code&gt;, it is similar to &lt;code&gt;CreateProcessAsUser&lt;/code&gt; the difference being the privileges required for the caller.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CreateProcessWithLogonW&lt;/code&gt; -&amp;gt; A handy shortcut to logon with a given user&amp;rsquo;s credentials (user, domain, and password).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All of the above have different use cases but eventually, all execution paths lead to &lt;code&gt;CreateProcessInternal&lt;/code&gt; which calls &lt;code&gt;NtCreateUserProcess&lt;/code&gt; (part of) which makes the transition to kernel mode and continue the kernel mode part of process creation with the same name. As the name suggests, &lt;code&gt;NtCreateUserProcess&lt;/code&gt; creates a user process. A user cannot create a native process, such as &lt;code&gt;smss.exe&lt;/code&gt; and &lt;code&gt;csrss.exe&lt;/code&gt;, as &lt;code&gt;CreateProcessInternal&lt;/code&gt; function will reject images with native subsystem image type.&lt;/p&gt;
&lt;p&gt;Apart from NT Processes, the Kernel Executive supports additional processes, that are created bypassing WinAPI, such as Native processes, Minimal or Pico Processes. These would be beyond the scope of this post.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You might be following along in a VM. If you are using VMware, you might notice performance slowdowns or hangs, which can get quite frustrating. There is a good way to get some more performace!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you&amp;rsquo;re using VMWare Player, make sure the VM is &amp;ldquo;Shut Down&amp;rdquo; and not &amp;ldquo;Suspended&amp;rdquo;. Then, navigate to the Virtual Machine working directory. Locate the config file &lt;code&gt;.vmx&lt;/code&gt;. Open that in an editor and add the following line to it -&amp;gt; &lt;code&gt;ulm.disableMitigations = &amp;quot;TRUE&amp;quot;&lt;/code&gt;. This will disable side-channel mitigations applied to your VM.&lt;/li&gt;
&lt;li&gt;If you&amp;rsquo;re using Workstation pro, then you can directly disable side-channel mitigations in &amp;ldquo;Edit Virtual Machine Settings&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;threads&#34;&gt;Threads&lt;/h3&gt;
&lt;p&gt;A thread is a subcomponent of process which does the actual execution. A process contain threads (at a minimum, 1 thread). Threads have their address space isolated from each other and share a common address space of the process. At OS-level, a Windows thread is represented by an executive thread object. This object encapsulates &lt;code&gt;nt!_ETHREAD&lt;/code&gt; (which is also an opaque kernel structure) which contains, among others, &lt;code&gt;nt!_KTHREAD&lt;/code&gt; structure as its first member. &lt;code&gt;nt!_KTHREAD&lt;/code&gt; points to several other structures all of which reside in system address space, with the exception of &lt;strong&gt;Thread Environment Block&lt;/strong&gt; (TEB). TEB, like PEB, resides in userspace.&lt;/p&gt;
&lt;p&gt;The Windows subsystem process (csrss) maintains a parallel data strucure &lt;code&gt;CSR_THREAD&lt;/code&gt;. For threads that have called a Windows subsystem &lt;code&gt;USER&lt;/code&gt; or &lt;code&gt;GDI&lt;/code&gt; function, kernel-mode portion of Windows Subsystem (&lt;code&gt;Win32k.sys&lt;/code&gt;) maintains a per-thread data structure (&lt;code&gt;W32THREAD&lt;/code&gt;) that the &lt;code&gt;KTHREAD&lt;/code&gt; structure points to.&lt;/p&gt;
&lt;p&gt;The simplest function to create a thread is &lt;code&gt;CreateThread&lt;/code&gt; function which creates a thread in the current process. On successful completion, a non-zero handle is returned and a unique thread ID if requested by the caller.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CreateRemoteThread&lt;/code&gt; is used to inject a thread into another process. It can be used by the debugger to force a break in a debugged process. The debugger injects the thread which immediately causes a breakpoint by calling the &lt;code&gt;DebugBreak&lt;/code&gt; function. Another use can be to obtain information about a process when running within the target process context, this can be done for legitimate or malicious purposes.&lt;/p&gt;
&lt;p&gt;Going back to &lt;code&gt;lkd&lt;/code&gt;, you can use it to examine &lt;code&gt;nt!_ETHREAD&lt;/code&gt; -&amp;gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;lkd&amp;gt; dt nt!_ETHREAD
   +0x000 Tcb              : _KTHREAD
   +0x480 CreateTime       : _LARGE_INTEGER
   +0x488 ExitTime         : _LARGE_INTEGER
   +0x488 KeyedWaitChain   : _LIST_ENTRY
   +0x498 PostBlockList    : _LIST_ENTRY
   ...
   +0x560 DisableDynamicCodeOptOut : Pos 18, 1 Bit
   +0x560 ExplicitCaseSensitivity : Pos 19, 1 Bit
   +0x560 PicoNotifyExit   : Pos 20, 1 Bit
   +0x560 DbgWerUserReportActive : Pos 21, 1 Bit
   +0x560 ForcedSelfTrimActive : Pos 22, 1 Bit
   +0x560 SamplingCoverage : Pos 23, 1 Bit
   ...
   +0x6b8 LastExpectedRunTime : Uint4B
   +0x6bc LastSoftParkElectionRunTime : Uint4B
   +0x6c0 LastSoftParkElectionGeneration : Uint8B
   +0x6c8 LastSoftParkElectionGroupAffinity : _GROUP_AFFINITY
   +0x6d8 UpdateTebListEntry : _SINGLE_LIST_ENTRY
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Listed above are the structures inside &lt;code&gt;nt!_ETHREAD&lt;/code&gt; and their types. For instance, &lt;code&gt;Tcb&lt;/code&gt; is of type &lt;code&gt;_KTHREAD&lt;/code&gt; and &lt;code&gt;CreateTime&lt;/code&gt; is an instance of &lt;code&gt;_LARGE_INTEGER&lt;/code&gt; structure.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;!thread&lt;/code&gt; can be used to view information about a thread. But this can only be used in kernel-mode debugging.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;lkd&amp;gt; !thread
   THREAD ffff830869dec080  Cid 24cc.0250  Teb: 0000003a3cb00000 Win32Thread: ffff83086dfe3da0 WAIT: (WrUserRequest) UserMode Non-Alertable
      ffff83086fb5f280  QueueObject
   IRP List:
      ffff83086eac8ba0: (0006,0358) Flags: 00060800  Mdl: 00000000
   Not impersonating
   DeviceMap                 ffffe586f8dcf270
   Owning Process            ffff83086fea80c0       Image:         DbgX.Shell.exe
   Attached Process          N/A            Image:         N/A
   Wait Start TickCount      5303564        Ticks: 748 (0:00:00:11.687)
   Context Switch Count      2299901        IdealProcessor: 1             
   UserTime                  00:05:51.000
   KernelTime                00:03:42.062
   Win32 Start Address 0x00007ff678783d50
   Stack Init ffff960b2293ac70 Current ffff960b2293a050
   Base ffff960b2293b000 Limit ffff960b22935000 Call 0000000000000000
   Priority 12 BasePriority 8 PriorityDecrement 2 IoPriority 2 PagePriority 5
   Unable to get context for thread running on processor 1, HRESULT 0x80004001
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The 64-bit hexadecimal number after &lt;code&gt;THREAD&lt;/code&gt; is the address of &lt;code&gt;ETHREAD&lt;/code&gt; block.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Two 16-bit hexadecimal numbers after &lt;code&gt;Cid&lt;/code&gt; are of the form &lt;em&gt;processID.threadID&lt;/em&gt;, processID is 0x24cc and threadID is 0x0250 in this case.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The 64-bit hexadecimal number after &lt;code&gt;Teb&lt;/code&gt; is the address of &lt;strong&gt;Thread Environment Block&lt;/strong&gt; (TEB).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The 64-bit hexadecimal number after &lt;code&gt;Win32Thread&lt;/code&gt; is the address of Win32Thread.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Apart from these, other fields show stack trace, priority, thread start address, owning process and thread state.&lt;/p&gt;
&lt;h3 id=&#34;virtual-memory&#34;&gt;Virtual Memory&lt;/h3&gt;
&lt;p&gt;It is what is written on the box, a memory that doesn&amp;rsquo;t really exists (but mapped). When a processor writes to a memory location it actually writes to a virtual address. The essence of virtual memory lies in the fact that, from an execution perspective the CPU doesn&amp;rsquo;t need to know whether the memory is mapped to RAM or Disk.&lt;/p&gt;
&lt;p&gt;Below is the layout for two &amp;ldquo;extreme&amp;rdquo; cases: 32-bit process on a 32-bit system (left) and a 64-bit process on a 64-bit system (right) -&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tx0actical.github.io/images/VMLayout.png&#34; alt=&#34;image&#34;&gt;
&lt;em&gt;Source: Windows Kernel Programming, 2nd Edition&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If the requested page doesn&amp;rsquo;t exist in RAM, the CPU raises a page fault exception, which causes the memory manager&amp;rsquo;s page fault exception handler to fetch data from file (if it&amp;rsquo;s a valid page fault), copy it to RAM, update the page table entries and instruct CPU to try again.&lt;/p&gt;
&lt;p&gt;Windows also supports large pages, by using &lt;strong&gt;Page Directory Entry&lt;/strong&gt; (PDE) to directly map a large page without using a page table. This makes better use of &lt;strong&gt;Translation Lookaside Buffer&lt;/strong&gt; (TLB) - a cache of recently translated pages maintained by the CPU.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A non-paged area is a memory region which is guaranteed to remain in memory as it&amp;rsquo;s never paged. But the Windows Bug Check error PAGE_FAULT_IN_NONPAGED_AREA (0x00000050) seemingly contradicts this idea that a page fault cannot happen in a region where the referenced memory is guranteed to be in RAM. Interesting!
A probable cause for this might be a situation where a driver misuses non-paged pool allocations and/or references invalid memory. Bad driver code or corrupt system memory is the major reason.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;mode-of-execution&#34;&gt;Mode of Execution&lt;/h3&gt;
&lt;p&gt;This refers to the nature of code being executed. Does that belongs to a user application or a part of a kernel component? The nature of code determines the privilege assigned to it. To support this structure, x64 processors are divided into privilege rings -&amp;gt; Ring 3 to Ring 0.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Actually, these rings go even deeper in modern Intel/AMD Processors -&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ring -1 : Hypervisor&lt;/li&gt;
&lt;li&gt;Ring -2 : System Management Mode&lt;/li&gt;
&lt;li&gt;Ring -3 : Intel Management Engine (ME)
Below these exists the Microcode and the actual Silicon.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;When a user launches an application, Windows creates a private virtual address space and a private handle table (more on this later). A user-mode application has its own private address space isolated from other processes and the OS. So, if a process crashes, it doesn&amp;rsquo;t affect other processes, they keep running.&lt;/p&gt;
&lt;p&gt;A kernel mode component, such as a Kernel-Mode driver, shares its address space with the whole kernel. This implies if a component crashes it takes the whole system with it. The kernel, &lt;strong&gt;Hardware Abstraction Layer&lt;/strong&gt; (HAL), and kernel drivers operate in kernel space.&lt;/p&gt;
&lt;h3 id=&#34;system-services&#34;&gt;System Services&lt;/h3&gt;
&lt;p&gt;Or System Calls are used to request kernel services like reading from file, thread creation etc. System calls in Windows follows a rather complex path as compared to Unix syscalls. Under Windows, user applications don&amp;rsquo;t call the native Windows OS services directly. Rather, they go through one or more subsystem Dynamic-Link Libraries (DLLs).&lt;/p&gt;
&lt;p&gt;Take file creation for example.&lt;/p&gt;
&lt;p&gt;When a user creates a new file in &lt;em&gt;Notepad&lt;/em&gt;, its code calls &lt;code&gt;CreateFile&lt;/code&gt;, which is documented, and implemented in &lt;code&gt;kernel32.dll&lt;/code&gt;. This function runs in user mode, so there is no way it can open a file. After some error checking, it calls &lt;code&gt;NtCreateFile&lt;/code&gt;, a function implemented in &lt;code&gt;ntdll.dll&lt;/code&gt;. It is documented and is the one that makes the actual transition to kernel-mode. Before the transition, it puts a number called &lt;strong&gt;System Service Number&lt;/strong&gt;, into a CPU register (&lt;code&gt;EAX&lt;/code&gt; on Intel/AMD architectures). Then it issues a special CPU instruction (&lt;code&gt;syscallon&lt;/code&gt; on x64 or &lt;code&gt;sysenter&lt;/code&gt; on x86) that makes the actual transistion to kernel-mode while jumping to a predefined routine called the &lt;strong&gt;System Service Dispatcher&lt;/strong&gt; (SSD). The SSD, in turn, uses the value in the &lt;code&gt;EAX&lt;/code&gt; register as an index into a &lt;strong&gt;System Service Dispatch Table&lt;/strong&gt; (SSDT). Using this table, the code jumps to the system service (call) itself. For the &lt;em&gt;Notepad&lt;/em&gt; example, the SSDT entry would point to &lt;code&gt;NtCreateFile&lt;/code&gt;, implemented by kernel I/O manager.&lt;/p&gt;
&lt;p&gt;This can be seen in action. Open &lt;em&gt;Notepad.exe&lt;/em&gt; in &amp;lsquo;WinDbg Preview&amp;rsquo;. Upon attaching to the process, the debugger will hit a default breakpoint -&amp;gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;(6b4.840): Break instruction exception - code 80000003 (first chance)
ntdll!LdrpDoDebuggerBreak+0x30:
00007ff8`fac8c0e0 cc              int     3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Set a breakpoint in &lt;code&gt;NtCreateFile&lt;/code&gt; inside &lt;code&gt;ntdll.dll&lt;/code&gt; using &lt;code&gt;bp ntdll!ntcreatefile&lt;/code&gt;. Then type &lt;code&gt;g&lt;/code&gt; (go) to continue execution. The newly set breakpoint will hit almost immediately.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;   ...
   Breakpoint 0 hit
   ntdll!NtCreateFile:
   00007ff8`fac50320 4c8bd1          mov     r10,rcx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Enter &lt;code&gt;u&lt;/code&gt; (unassembled) command to see a few instructions ahead -&amp;gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;0:000&amp;gt; u
   ntdll!NtCreateFile:
   00007ff8`fac50320 4c8bd1          mov     r10,rcx
   00007ff8`fac50323 b855000000      mov     eax,55h
   00007ff8`fac50328 f604250803fe7f01 test    byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],1
   00007ff8`fac50330 7503            jne     ntdll!NtCreateFile+0x15 (00007ff8`fac50335)
   00007ff8`fac50332 0f05            syscall
   00007ff8`fac50334 c3              ret
   00007ff8`fac50335 cd2e            int     2Eh
   00007ff8`fac50337 c3              ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As mentioned above, &lt;code&gt;EAX&lt;/code&gt; is set with SSN -&amp;gt; 0x55. This is the system call number. Then notice the &lt;code&gt;syscall&lt;/code&gt; instruction. This switches the processor to kernel-mode, jumping to the SSDT entry corresponding to the value inside &lt;code&gt;EAX&lt;/code&gt;. Predictably, 0x55 corresponds to &lt;code&gt;NtCreateFile&lt;/code&gt;. Notice the flag value set to 1 at offset 0x308 to &lt;code&gt;SharedUserData&lt;/code&gt;. If this flag is set, the execution will take another path using the &lt;code&gt;int 2Eh&lt;/code&gt; instruction on the second to last line of the output above. This flag corresponds to a specific Credential Guard VBS (Virtualization Based Security) feature as the hypervisor can better react to &lt;code&gt;int&lt;/code&gt; instruction rather than &lt;code&gt;syscall&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Alright! Enough for this one!&lt;/p&gt;
&lt;h3 id=&#34;objects-and-handles&#34;&gt;Objects and Handles&lt;/h3&gt;
&lt;p&gt;In Windows, a kernel object is a single, runtime instance of a statically defined object. They are kernel data structures representing commonly used facilities like files, registry keys, processes, threads, devices etc. that are managed by the Object Manager, a component of the Windows Kernel. All such objects are preceded by an &lt;code&gt;nt!_OBJECT_HEADER&lt;/code&gt; structure that contains information about the object and is used to manage the life cycle of the object, allow the object to be uniquely named, secure the object by applying access control, invoke object type specific methods and track the allocator&amp;rsquo;s quota usage.&lt;/p&gt;
&lt;p&gt;Handles are references returned to caller by the callee (APIs in this case) which are then translated to pointers by WDF. Processes in Windows have their own handle table which is stored in the kernel virtual address space. &lt;code&gt;nt!_HANDLE_TABLE_ENTRY&lt;/code&gt; represents an individual entry in the process&amp;rsquo; handle table. Handle tables are allocated from Paged Pool. When a process terminates the function &lt;code&gt;ExSweepHandleTable()&lt;/code&gt; closes all handles in the handle table of that process.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;!handle&lt;/code&gt; can be used to examine the handle table of any process. Output would be very large!&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dbgcmd&#34; data-lang=&#34;dbgcmd&#34;&gt;***************************
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;subsystems-subsystem-dlls-and-ntdlldll&#34;&gt;Subsystems, Subsystem DLLs and ntdll.dll&lt;/h3&gt;
&lt;p&gt;A subsystem is a facility by which Windows exposes some subset of the base Windows executive system services to application programs. This means that some things that can be done from an application built on one subsystem can&amp;rsquo;t be done by another application built on another subsystem. Each executable image &lt;code&gt;.exe&lt;/code&gt; is bound to only one subsystem. During process creation, the process creation code examines the sub-system type header code and notify the target subsystem of the new process. This type code is defined in the &lt;code&gt;/SUBSYSTEM&lt;/code&gt; linker flag of Visual Studio Linker.&lt;/p&gt;
&lt;p&gt;You can view the image subsystem type using the Dependency Walker (depends.exe). If you check &lt;em&gt;notepad.exe&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tx0actical.github.io/images/dependsNotepad.png&#34; alt=&#34;depends&#34;&gt;&lt;/p&gt;
&lt;p&gt;The role of subsystem DLLs is to translate a documented function into the appropriate internal (and generally undocumented) native system service calls implemented mostly in &lt;code&gt;NTDLL.DLL&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NTDLL.DLL&lt;/code&gt; comprises the lowest layer of code that still runs in user mode. It acts a special support library primarily for the use of subsystem DLLs and native applications. Native images are those images that are not tied to any particular subsystem.&lt;/p&gt;
&lt;h3 id=&#34;hardware-abstraction-layer-hal&#34;&gt;Hardware Abstraction Layer (HAL)&lt;/h3&gt;
&lt;p&gt;The HAL is a loadable kernel-mode module (Hal.dll) that provides the low-level interface to the hardware platform on which Windows is running. This is a layer of code that isolates the kernel, the device drivers, and the rest of the Windows Executive from platform-specific hardware differences.&lt;/p&gt;
&lt;p&gt;It hides hardware-dependent details such as I/O interfaces, interrupt controllers, and multiprocessor communication mechanisms — any functions that are both architecture-specific and machine-dependent. So rather than access hardware directly, Windows internal components and user-written device
drivers maintain portability by calling the HAL routines when they need platform-dependent information. For this reason, many HAL routines are documented in the WDK.&lt;/p&gt;
&lt;h3 id=&#34;hyper-v-hypervisor-and-driver-code-security-challenges&#34;&gt;Hyper-V Hypervisor and Driver Code Security Challenges&lt;/h3&gt;
&lt;p&gt;This contains the hypervisor. There are no drivers or other modules in this environment. That being said, the hypervisor itself is composed of multiple internal layers and services, such as its own Memory Manager, Virtual Processor scheduler, Interrupt and Time management, Synchronization Routines, Partitions (VM instances) management and Inter-Partition Communication (IPC) and more. This is one level below Ring 0 privilege, Ring -1.&lt;/p&gt;
&lt;p&gt;One of the main roles of Hyper-V in Windows 10 and Windows Server 2016 (and later) to enable support for Virtualization Based Security (VBS).&lt;/p&gt;
&lt;p&gt;VBS provides an extra layer of security as the normal OS exists as a Hyper-V VM. Windows uses Virtual Trust Levels (VTLs), which uses the hypervisor to configure virtual trust levels. This is to address challenges arising from malicious driver code which could access kernel-mode memory.&lt;/p&gt;
&lt;p&gt;VBS provides extra security on top of processor isolation.&lt;/p&gt;
&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In this post you learnt about Windows Processes, Threads, and System Services and other specific topics like Virtual Memory, Objects and Handles.&lt;/p&gt;
&lt;p&gt;In the next post, you&amp;rsquo;ll start building your first driver.&lt;/p&gt;
&lt;p&gt;Stay Tuned!&lt;/p&gt;
&lt;p&gt;Tx0actical. Out.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This post draws inspiration from &lt;a href=&#34;https://www.microsoftpressstore.com/store/windows-internals-part-1-system-architecture-processes-9780735684188&#34;&gt;Windows Internals&lt;/a&gt;, if you wish to dive even deeper (The book, for instance, explains Session Manager, &lt;code&gt;smss.exe&lt;/code&gt; in 38 points!), &lt;a href=&#34;https://leanpub.com/windowskernelprogrammingsecondedition&#34;&gt;Windows Kernel Programming&lt;/a&gt;, the official &lt;a href=&#34;https://learn.microsoft.com/en-us/windows/&#34;&gt;Microsoft documentation&lt;/a&gt; and &lt;strong&gt;my own experimentation&lt;/strong&gt;. Also, if you wish to dive deeper into Windows Internals for security research, I would highly recommend &lt;a href=&#34;https://codemachine.com/index.html&#34;&gt;CodeMachine&lt;/a&gt;, they provide training for all things &amp;ldquo;Windows Security&amp;rdquo;. Some of their articles have also inspired this post.&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
  </channel>
</rss>
